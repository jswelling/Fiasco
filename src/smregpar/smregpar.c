/************************************************************
 *                                                          *
 *  smregpar.c                                              *
 *                                                          *
 *  Permission is hereby granted to any individual or       *
 *  institution for use, copying, or redistribution of      *
 *  this code and associated documentation, provided        *
 *  that such code and documentation are not sold for       *
 *  profit and the following copyright notice is retained   *
 *  in the code and documentation:                          *
 *     Copyright (c) 1995 Department of Statistics,         *
 *                        Carnegie Mellon University        *
 *                                                          *
 *  This program is distributed in the hope that it will    *
 *  be useful, but WITHOUT ANY WARRANTY; without even the   *
 *  implied warranty of MERCHANTABILITY or FITNESS FOR A    *
 *  PARTICULAR PURPOSE.  Neither Carnegie Mellon University *
 *  nor any of the authors assume any liability for         *
 *  damages, incidental or otherwise, caused by the         *
 *  installation or use of this software.                   *
 *                                                          *
 *  CLINICAL APPLICATIONS ARE NOT RECOMMENDED, AND THIS     *
 *  SOFTWARE HAS NOT BEEN EVALUATED BY THE UNITED STATES    *
 *  FDA FOR ANY CLINICAL USE.                               *
 *                                                          *
 *                                                          *
 *  Original programming by Mark Fitzgerald  2-95           *
 *     5-96: Pittsburgh Format, Mark Fitzgerald             *
 ************************************************************/
/*************************************************************

  DESCRIPTION OF SMREGPAR.C

  smregpar.c smooths registration parameters generated by estireg.c .
  The results are written to a parameter file, which is in turn used
  to register image data.

  smregpar.m [-headerinput Input-header-file]
             [-parameterin Registration-parameter-file]
             [-parameterout Output-parameter-file] 
	     [-cutoff Num-MSE-IQRs] [-fixed Fixed-image-number]
	     [-bandwidth Kernel-band] [-kernel Kernel-type] 
	     [-threshold Change-point-threshold]

**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <math.h>
#include <ctype.h>
#include "mri.h"
#include "fmri.h"
#include "misc.h"
#include "stdcrg.h"

static char rcsid[] = "$Id: smregpar.c,v 1.19 2007/03/22 00:08:34 welling Exp $";

static void writeParFileHeader(FILE* ofile)
{
  fprintf(ofile,"##Format: order:index_tz, type:filtered\n");
  fprintf(ofile,"##Format: names:(xshift,yshift,rotation,mse)\n");
}

/* This function provides the metric used to check the threshold
 *  cutoff value for smoothing.
 */
static float thresh_value( Smoother* smoother, float** dtbl, int ndata,
			   int n1, int n2 )
{
  float result= 0.0;

  if (n1==n2) return 0.0;
  else {
    float sqdiffx;
    float sqdiffy;
    float sqdiffrot;

    sqdiffx= dtbl[0][n1] - dtbl[0][n2];
    sqdiffx *= sqdiffx;
    result += sqdiffx;
    sqdiffy= dtbl[1][n1] - dtbl[1][n2];
    sqdiffy *= sqdiffy;
    result += sqdiffy;
    sqdiffrot = dtbl[2][n1] - dtbl[2][n2];
    sqdiffrot *= sqdiffrot;
    result += sqdiffrot;
  }

  return result;
}

int main( int argc, char* argv[] ) 
{
  MRI_Dataset *Input = NULL;
  FILE *ifp = NULL, *ofp = NULL;
  char infile[512], iparfile[512], oparfile[512], kernel[512];
  char fixed_image_string[512];
  float bandwidth;
  float cutoff;
  float threshold;
  unsigned char **missing = NULL;
  char scanline[512];
  long linenum, numread;
  long dx, dy, dt, dz, t, z, tt, zz;
  RegPars **par = NULL, **corr_par = NULL, tmpreg;
  float **mse = NULL, **corr_mse = NULL, tmpmse;
  float *ordmse = NULL, medianmse, iqrmse, msecutoff;
  long msecount;
  long fixed_image, working_fixed_image;
  float rotparadj, sqdiffx, sqdiffy, sqdiffrot, distance;
  float weight, totalweight;
  Smoother* smoother;
  sm_type smoother_type;
  float* smooth_ibuf= NULL;
  float* smooth_obuf= NULL;
  float* smooth_itbl[4];
  float* smooth_otbl[4];

  /* Print version number */
  Message( "# %s\n", rcsid );

  sm_init();

  /* Check to see if help was requested */
  if( ( argc > 1 ) && !strcmp( argv[1], "-help" ) )
    {
      if( argc == 2 )
	Help( "selecttopic" );
      else
	Help( argv[2] );
    }


  /*** Parse command line ***/

  cl_scan( argc, argv );

  /* Get filenames */
  cl_get( "headerinput|h", "%option %s[%]", "input.mri", infile );
  cl_get( "parameterin", "%option %s[%]", "reg.par", iparfile );
  cl_get( "parameterout", "%option %s[%]", "smreg.par", oparfile );
  cl_get( "cutoff|c", "%option %f[%]", 10.0, &cutoff );
  cl_get( "fixed|f", "%option %s[%]", "-1", fixed_image_string );
  cl_get( "bandwidth|b", "%option %f[%]", 3.0, &bandwidth );
  cl_get( "kernel|k", "%option %s[%]", "gaussian", kernel );
  cl_get( "threshold|t", "%option %f[%]", 0.01, &threshold );

  if( !strcasecmp( kernel, "gaussian" ) || !strcasecmp( kernel, "g" ) )
    {
      smoother_type= SM_GAUSSIAN;
    }
  else if( !strcasecmp( kernel, "triangular" ) || !strcasecmp( kernel, "t" ) )
    {
      smoother_type= SM_TRIANGULAR;
    }
  else if( !strcasecmp( kernel, "exponential" ) || !strcasecmp( kernel, "e" ) )
     {
      smoother_type= SM_POWER;
    }
  else {
    Abort( "Kernel unrecognized (%s).", kernel );
  }

  sm_set_params( smoother_type, bandwidth, 0.0, threshold, 
		 (SmootherThreshTest)thresh_value);
  sm_parse_cl_opts();
  sm_get_params( &smoother_type, &bandwidth, NULL, &threshold, NULL );

  if (cl_cleanup_check()) {
    int i;
    fprintf(stderr,"%s: invalid argument in command line:\n    ",argv[0]);
    for (i=0; i<argc; i++) fprintf(stderr,"%s ",argv[i]);
    fprintf(stderr,"\n");
    Help( "usage" );
    exit(-1);
  }

  /*** End command-line parsing ***/


  /* Open input dataset */
  Input = mri_open_dataset( infile, MRI_MODIFY );
  hist_add_cl(Input,argc,argv); /* since we will change missing chunk */

  /* Check that program will function on data-set */
  if( !mri_has( Input, "images" ) )
    Abort( "%s operates only on standard images.", argv[0] );
  if( !mri_has( Input, "images.dimensions" ) ||
      ( strcmp( mri_get_string( Input, "images.dimensions" ), "vxyzt" ) &&
	strcmp( mri_get_string( Input, "images.dimensions" ), "xyzt" ) ) )
    Abort( "%s only works on standard images in (v)xyzt format.", infile );

  /* Read/Create missing image indicators */
  missing = get_missing( Input );

  /* Set parameters in local variables */
  if( !mri_has( Input, "images.extent.t" ) ||
      !mri_has( Input, "images.extent.x" ) ||
      !mri_has( Input, "images.extent.y" ) ||
      !mri_has( Input, "images.extent.z" ) )
    Abort( "images.extent key(s) missing from header." );
  dt = mri_get_int( Input, "images.extent.t" );
  dx = mri_get_int( Input, "images.extent.x" );
  dy = mri_get_int( Input, "images.extent.y" );
  dz = mri_get_int( Input, "images.extent.z" );
  if( ( dt <= 0 ) || ( dx <= 0 ) || ( dy <= 0 ) || ( dz <= 0 ) )
    Abort( "%s: images.extent key(s) is non-positive.\n", argv[0] );
  if (dt<2) Abort("%s: not enough data to smooth.\n", argv[0]);

  /* Find a fixed image based on the given string.  It could be an
   * integer, or a word like "middle", "center", or "mean".
   */
  if (strcasecmp(fixed_image_string, "middle" ) == 0 ||
      strcasecmp(fixed_image_string, "center" ) == 0)
    fixed_image = dt / 2;
  else if (!strcasecmp(fixed_image_string, "mean")) {
    fixed_image= -1; /* use no fixed image */
  }
  else {
    char* runner= fixed_image_string;
    if (!isdigit(*runner) && !(index("+-",*runner))) {
      /* This is presumably a filename; ignore it */
      fixed_image= -1; /* use no fixed image */
    }
    else {
      runner++;
      for ( ; *runner; runner++ )
	if (!isdigit(*runner) && !index("+-",*runner)) {
	  /* First character is a digit but it's not an integer */
	  Abort("%s: unrecognized fixed image <%s>!\n",
		argv[0],fixed_image_string);
	}
      fixed_image= atoi(fixed_image_string);
      if (fixed_image >= dt) fixed_image= dt-1;
    }
  }

  /* Calculate degrees-radians, scaling rotation correction */
  rotparadj = ( pow( (float) dx, 2.0 ) + pow( (float) dy, 2.0 ) ) / 3.0 *
    pow( ( M_PI / 180.0 ), 2.0 );

  /* Allocate storage and initialize */
  par = Matrix( dt, dz, RegPars );
  corr_par = Matrix( dt, dz, RegPars );
  mse = Matrix( dt, dz, float );
  corr_mse = Matrix( dt, dz, float );
  ordmse = (float *) emalloc( dt * sizeof(float) );
  for( t = 0; t < dt; t++ )
    for( z = 0; z < dz; z++ )
      {
	par[t][z].x_shift = par[t][z].y_shift =
	  par[t][z].rotation = corr_par[t][z].x_shift =
	  corr_par[t][z].y_shift = corr_par[t][z].rotation = 0.0;
	mse[t][z] = -1.0;
      }
  if (!(smooth_ibuf= (float*)malloc(4*dt*sizeof(float))))
    Abort("%s: unable to allocate %d floats!\n",argv[0],4*dt);
  smooth_itbl[0]= smooth_ibuf;
  smooth_itbl[1]= smooth_ibuf+dt;
  smooth_itbl[2]= smooth_ibuf+(2*dt);
  smooth_itbl[3]= smooth_ibuf+(3*dt);
  if (!(smooth_obuf= (float*)malloc(4*dt*sizeof(float))))
    Abort("%s: unable to allocate %d floats!\n",argv[0],4*dt);
  smooth_otbl[0]= smooth_obuf;
  smooth_otbl[1]= smooth_obuf+dt;
  smooth_otbl[2]= smooth_obuf+(2*dt);
  smooth_otbl[3]= smooth_obuf+(3*dt);

  /* Read in estimated registration parameters */
  ifp = efopen( iparfile, "r" );
  linenum = -1;
  while( !feof( ifp ) && !ferror( ifp ) )
    {
      linenum++;

      /* Scan a line */
      fgets(scanline, sizeof(scanline), ifp);
      if (scanline[0]=='#') continue;
      numread = sscanf( scanline, "%ld%ld%f%f%f%f", &tt, &zz,
			&(tmpreg.x_shift), &(tmpreg.y_shift),
			&(tmpreg.rotation), &tmpmse );

      if( ( numread < 6 ) )
	{
	  if( feof( ifp ) )
	    break;
	  else
	    {
	      Warning( 1, "Line %ld of %s is too short (%ld) -- Ignored.\n",
		       linenum, iparfile, numread );
	      continue;
	    }
	}

      if( ( tt < 0 ) || ( tt >= dt ) || ( zz < 0 ) || ( zz >= dz ) )
	{
	  Warning( 1,
		   "Image/Slice number out of bounds (%ld/%ld) for line %ld of %s -- Ignoring.\n",
		   tt, zz, linenum, iparfile );
	  continue;
	}
      
      /* Put parameters into appropriate storage */
      par[tt][zz].x_shift = tmpreg.x_shift;
      par[tt][zz].y_shift = tmpreg.y_shift;
      par[tt][zz].rotation = tmpreg.rotation;
      mse[tt][zz] = tmpmse;
    }

  /* Create smoother with specified params */
  smoother= sm_create_smoother();

  /* A needed heading */
  fprintf(stdout,"Slice  Median delta MSE      IQR\n");
  
  /* Loop through slices */
  for( z = 0; z < dz; z++ )
    {
  
      /* Find fixed image */
      working_fixed_image = fixed_image;
      if( ( fixed_image >= 0 ) && ( fixed_image < dt ) )
	{
	  while( missing[working_fixed_image][z] ||
		 ( mse[working_fixed_image][z] != 0.0 ) )
	    {
	      working_fixed_image++;
	      if( working_fixed_image == dt )
		working_fixed_image = 0;
	      if( working_fixed_image == fixed_image )
		{
		  working_fixed_image = -1;
		  break;
		}
	    }
	  if (working_fixed_image<0) 
	    Warning(1,
		    "%s: can't find a valid image to hold fixed (slice %d)!\n",
		    argv[0],z);
	}

      /* Do a pass of smoothing including all fields, to
       * produce smoothed MSE values that will be used in
       * deciding which slices are marked missing.  We patch
       * over the zero value of mse at the fixed image to
       * avoid disturbing the smoothed mse curve.
       */
      for (t=0; t<dt; t++) {
	smooth_itbl[0][t]= par[t][z].x_shift;
	smooth_itbl[1][t]= par[t][z].y_shift;
	smooth_itbl[2][t]= par[t][z].rotation;
	smooth_itbl[3][t]= mse[t][z];
      }
      if (working_fixed_image>0) {
	if (working_fixed_image<dt-1) {
	  smooth_itbl[3][working_fixed_image]= 
	    0.5*(mse[working_fixed_image-1][z]+mse[working_fixed_image+1][z]);
	}
	else 
	  smooth_itbl[3][working_fixed_image]= mse[working_fixed_image-1][z];
      }
      else if (working_fixed_image==0) {
	smooth_itbl[3][working_fixed_image]= mse[1][z];
      }
      else if (working_fixed_image<0) {
	/* do nothing; no need to patch. */
      }

      SM_SMOOTH_GROUP( smoother, smooth_itbl, smooth_otbl, 4, dt, 
		       missing, z );
      for (t=0; t<dt; t++) corr_mse[t][z]= smooth_otbl[3][t];
      if (working_fixed_image>=0) 
	corr_mse[working_fixed_image][z]= mse[working_fixed_image][z];

      /* MAKE "MISSING" EVALUATIONS BASED ON MSE'S */
          
      /* Sort MSE's ignoring fixed images and missing values */
      msecount = 0;
      for( t = 0; t < dt; t++ )
	if( ( t != working_fixed_image ) && ( mse[t][z] >= 0 ) )
	  ordmse[msecount++] = mse[t][z]-corr_mse[t][z];
      fqsrt( ordmse, 0, (long) ( msecount - 1 ) );
      
      /* Calculate median and iqr for MSE's */
      medianmse = ordmse[(long) ( msecount / 2 )];
      iqrmse = ordmse[(long) ( 3 * msecount / 4 )] -
	ordmse[(long) ( msecount / 4 )];
      fprintf(stdout,"  %d        %g      %g\n",z,medianmse,iqrmse);

      /* Set maximum allowable value for uncontaminated MSE */
      msecutoff = medianmse + cutoff * iqrmse;

      /* If MSE is too far above smoothed MSE for an image, or is
       * negative, set the image to missing.
       */
      for( t = 0; t < dt; t++ )
	{
	  if( (t != working_fixed_image) 
	      && (( mse[t][z] < 0.0 ) 
		  || ( mse[t][z] - corr_mse[t][z] > msecutoff )) )
	    missing[t][z] = (unsigned char) 1;
	}

      /* END "MISSING" EVALUATIONS */     
      
      /* Smooth registration parameters again using new missing info,
       * without smoothing MSE.  Data for fixed image is unchanged.
       */
      SM_SMOOTH_GROUP( smoother, smooth_itbl, smooth_otbl, 3, dt, 
		       missing, z );
      for (t=0; t<dt; t++) {
	corr_par[t][z].x_shift= smooth_otbl[0][t];
	corr_par[t][z].y_shift= smooth_otbl[1][t];
	corr_par[t][z].rotation= smooth_otbl[2][t];
      }
      if (working_fixed_image >= 0) {
	corr_par[working_fixed_image][z].x_shift= 
	  par[working_fixed_image][z].x_shift;
	corr_par[working_fixed_image][z].y_shift= 
	  par[working_fixed_image][z].y_shift;
	corr_par[working_fixed_image][z].rotation= 
	  par[working_fixed_image][z].rotation;
	corr_mse[working_fixed_image][z]= mse[working_fixed_image][z];
      }

      /* END SMOOTHING */

    }

  /* Write out missing chunk, since it may have changed */
  mri_set_chunk( Input, "missing", (long) ( dt * dz ), 0,
		 MRI_UNSIGNED_CHAR, *missing );  

  /* Close data set */
  mri_close_dataset( Input );
      
  /* Write out new parameters */
  ofp = efopen( oparfile, "w" );
  writeParFileHeader(ofp);
  for( t = 0; t < dt; t++ )
    for( z = 0; z < dz; z++ )
      fprintf( ofp, "%5ld %3ld %14.9f %14.9f %14.9f %14.6f\n",
	       t, z, corr_par[t][z].x_shift, corr_par[t][z].y_shift,
	       corr_par[t][z].rotation, corr_mse[t][z] );
  efclose( ofp );

  /* Clean up a bit */
  sm_destroy(smoother);
  free( smooth_ibuf );
  free( smooth_obuf );

  Message( "#      Registration parameter smoothing complete.\n" );
  return 0;

}



