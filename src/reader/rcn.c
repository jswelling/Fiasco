static const char rcsid[] = "$Id: rcn.c,v 1.7 2007/03/22 00:03:47 welling Exp $";

/*
 * Revision 1.13  1997/12/3    8:46:58  mock
 * Started to add functionality to handle multi-shot EPI data.  Specifically,
 * added reorder_ileav() and modified the fliprowx() routine to use array
 * filled with data from the rowflip.param file generated by the epibold
 * psd and stored in /usr/g/bin.  Since I was doing this brute force 
 * before, I may need to modify how the image orientation is handled 
 * in the main.
 *
 * Revision 1.12  1997/10/23  Mock 
 * Added memcopy functions to read exam, series, image structures from memory without using
 * Carl Crawfords byte-swapping routines since they aren't needed for the lx platform
 *
 * Revision 1.11  1996/01/10  15:29:17  mock
 * Changed readraw routine to read in epibold data accounting for
 * slice, nex, baseline and header offset. 
 * Add 1dfft routine for performing ahn correction to EPI data
 * Modified Pady and Padx routines to pad asymmetrically for fract Ky
 * and fract FOV EPI scans
 * Add routine to flip raw data about Kx, Ky = 0 to account for
 * some image orientations
 *
 * Revision 1.10  1994/09/16  17:49:40  polzin
 * Add routine writesigna to write out file image file with control data,
 * exam, series, and image header stuff.
 *
 * Revision 1.9  1994/06/19  20:49:37  polzin
 * Fixed casting bug in writeimage.
 *
 * Revision 1.8  1994/05/02  21:31:32  polzin
 * Fixed bug in writeimage scaling.
 *
 * Revision 1.7  1994/04/28  16:32:49  polzin
 * Modified writeimage to check if pixel values were overranging and if
 * they are scale them appropriately. Now scaling is only done if
 * necessary on ffted data.
 *
 * Revision 1.6  1994/03/02  21:36:19  polzin
 * Tried to improve efficiency of pd, mag, and cd routines.
 * Started to add routine to rotate image by 90 degrees.
 *
 * Revision 1.5  1994/02/18  01:17:43  polzin
 * Added support routines for phased-array phase-contrast recon,
 * pamag, pacd, and papd.
 *
 * Revision 1.4  1994/02/01  01:23:29  polzin
 * Allocate memory for raw data in readraw subroutine and
 * return a pointer to it.
 *
 * Revision 1.3  1994/02/01  00:00:24  polzin
 * Return entire pool header structure in routine readpool
 *
 * Revision 1.2  1994/01/19  18:06:33  polzin
 * Added average image calculation routine.
 * General clean-up.
 *
 * Revision 1.1  1994/01/14  22:28:55  polzin
 * Initial revision
 */


#include <stdio.h>
#include <string.h>
#include "nr_sub.h"
#include "mri.h"
#include "fmri.h"
#include "misc.h"
#include "stdcrg.h"
/* #include "sunmath.h" */  
#include <math.h>
#include <stdlib.h>
#include "rcn.h"
#ifdef never
#include "io_signa_lx.h"
#endif
#define MAXSHORT 32767
#ifndef M_PI
#define M_PI    3.14159265358979323846
#endif
extern int debug;

/**************************************************************************/
/*Read raw data header file into structure POOL_HEADER defined in rdbm.h*/

#ifdef never
int readpool(char filename[],void *phead)
{
  FILE *fphead;
  
  if ((fphead = fopen(filename,"rb+"))!=NULL)
    {
      if (debug) Message("seeking beginning of file\n");
     fseek(fphead, (long) 0, (int) 0);
      if (debug) Message("reading from header.\n");
      fread((void *)phead,sizeof(POOL_HEADER),1, fphead);
      if (debug) Message("closing file.\n");
      fclose(fphead);
    }
  else
    return(1);

  return(0);
}
#endif


/**************************************************************************/
/* Read data from  slicenum in filename into complex data array */
#ifdef never
fcomplex *readraw(int slicenum, int numslice, int rep, int frame,
  float rbw,int xres, int yres, int rcyres, int psize, int nmbl,
  char filename[])
{
  fcomplex *data;

  scomplex *raw;
  icomplex *iraw;

  int offset;
  int i,j;
  int image_no, image_off;
  int blsave = 1;     /* NOTE: genesis one  baseline view is allocated  */
                      /* by recon even if it isnt collected.  In LX,    */
                      /* CERD doesnt allocate baseline unless collected */ 
  FILE *fpraw;

  image_no = rep*numslice+slicenum;
  image_off = 2*(frame)*image_no;

/* calculate offset to slice and rep */
/* NOTE: BJM (1/24/96) removed rbw dependence on how data is read in */
/* since the number of baselines doesn't depend on which receiver is */
/* used if epibold is run correctly */

#ifdef LX_SYSTEM
  blsave = 0;
#endif

  offset = 
      (int)sizeof(POOL_HEADER)        /* header offset - "2's" for complex */
      + 2*psize*(nmbl + blsave)*xres  /* base-line offset */
      + 2*(frame)*slicenum        /* offset to slicenum raw data set */
      + 2*frame*numslice*rep;     /* offset for each repetition */ 

if(debug)  
printf("Total Offset = %d\n" 
       "POOL HEADER = %d\n"
       "RDB HEADER = %d\n"
       "Slice Offset = %d\n"
       "Baseline (bytes) skipped = %d\n"
       "Frame = %d\n"
       "Rep # = %d\n"
       "Point Size (bytes) = %d\n", 
       offset, (int)sizeof(POOL_HEADER), RDB_HEADER_SIZE_BYTES,
       slicenum, nmbl,frame, rep, psize);

/*Allocate memory for raw data */
  if (psize < 4) {
    if ((raw =(scomplex *)calloc((size_t)xres*yres,sizeof(scomplex)))==NULL)
        {
            Abort("Allocation failure for raw (scomplex).\n");
        }   

  } else {
    /*Allocate memory for raw data - extended dynamic range */
    if ((iraw =(icomplex *)calloc((size_t)xres*yres,sizeof(icomplex)))==NULL)
        {
            Abort("Allocation failure for raw (icomplex).\n");
        }
  }

   if ((data =(fcomplex *)calloc((size_t)xres*yres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for data.\n");
    }
  
  if ((fpraw = fopen(filename,"rb+"))!=NULL)
    {
      fseek(fpraw, (long) offset, (int) 0);
      if(psize < 4){
          fread(raw, sizeof(scomplex),xres*yres, fpraw);
      } else {
          fread(iraw, sizeof(icomplex),xres*yres, fpraw);
      }
      fclose(fpraw);
    }
  else
    return(NULL);
  
 /* Transfer raw data into real and imaginary arrays */
 for(j=0; j<yres; j++)
   for(i=0; i<xres; i++)
      {
        if(psize < 4) 
            {
	      data[j*xres + i].r = (float)raw[j*xres + i].r;
              data[j*xres + i].i = (float)raw[j*xres + i].i;
            } else { 
	      data[j*xres + i].r = (float)iraw[j*xres + i].r;
              data[j*xres + i].i = (float)iraw[j*xres + i].i;
            }
      }

  /* free memory for raw data */
  if (psize < 4) 
      free(raw);
  else 
     free(iraw);

  return(data);
} 
#endif

/**************************************************************************/
/* chop data in column direction. That is multiply even column indices by */
/* 1 and odd data points by -1 */

int choprawx(fcomplex data[],int xres,int yres)
{
  int i,j;
  
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
      if (i%2)
	{
	  data[j*xres+i].r *= -1;
	  data[j*xres+i].i *= -1;
	}
      
    }
if(debug)
 printf("Chopping Raw Data in X\n");

  return(0);
  
}

/**************************************************************************/
/* Chop data in row direction. That is multiply even row indices by */
/* 1 and odd data points by -1 */

int choprawy(fcomplex data[],int xres,int yres)
{
  int i,j;
  
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
      if (j%2)
	{
	  data[j*xres+i].r *= -1;
	  data[j*xres+i].i *= -1;
	}
      
    }

if(debug)
  printf("Chopping Raw Data in Y\n");
  
  return(0);
  
}

/**************************************************************************/
/* Chop data in row direction. That is multiply even row indices by */
/* 1 and odd data points by -1 */
int choprawy_ileave(fcomplex z[],int xres, int yres,int numlv,int *rwflip, int rflp_flag) 
{
  int i,j;
  
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
        if(rflp_flag) {
           if( rwflip[j] == 1) 
           {
	      z[j*xres+i].r *= -1;      
	      z[j*xres+i].i *= -1;
           } /* chop lines specified by rowflip.param */
        } else {
            if(numlv > 1) 
            { 
              if((j/numlv)%2 == 0) 
              {
	        z[j*xres+i].r *= -1;      
	        z[j*xres+i].i *= -1;
              } else {
                if(j%2 == 0) {
	           z[j*xres+i].r *= -1;      
	           z[j*xres+i].i *= -1;
                } /* chop every other line for single shot */
              }
            } 
        }
      
    }

if(debug)
  printf("Chopping Raw Data in Y\n");
  
  return(0);
  
}         

/**************************************************************************/
/*Shift data along x (readout direction) to correct for fractional */
/*echo */
int xshift(int shift,fcomplex data[],int xres,int yres)
{
  int i,j;
  
  for(i=xres-1;i>-1;i--)
    for(j=yres-1;j>-1;j--)
      {
      if(i>=shift)
	{
	  data[j*xres+i].r = data[j*xres+(i-shift)].r;
	  data[j*xres+i].i = data[j*xres+(i-shift)].i;
	}
      else
	{
	  data[j*xres+i].r = 0.;
	  data[j*xres+i].i = 0.;
	}  
    }

if(debug)
  printf("Shifting Raw Data in X for fractional echo scan\n");

  return(0);
  
}
/**************************************************************************/
/*Shift data along x (readout direction) to correct for fractional */
/*echo -- for truncated readout */
int xshift2(int shift,fcomplex *data[],int xres,int yres)
{
  int i,j;
  fcomplex *dshft;
  
  if ((dshft =
       (fcomplex *)calloc((size_t)(xres+shift)*yres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for dshft.\n");
    }

  for(j=yres-1;j>-1;j--)  
    for(i=xres-1;i>-1;i--)
      {
	dshft[j*(xres+shift)+i+shift].r = (*data)[j*xres+i].r;
	dshft[j*(xres+shift)+i+shift].i = (*data)[j*xres+i].i;
      }  

  free(*data);
  *data = dshft;

if(debug)
  printf("Shifting Raw Data in X for fractional echo scan\n");

  return(0);
}

/**************************************************************************/
/* Perform 2D FFT on data in complex array using Numerical */
/* Recipes routine */

int i2dfft(fcomplex data[], int xres,int yres, float scale, int direct)
{
  int i,j;

#ifdef never
/*  float scale;*/
  unsigned long int nn[2];
  
  nn[0] = xres;
  nn[1] = yres;
  
  /* Numerical recipes uses unitary offset arrays*/
  nr_fourn((float *)data-1,nn-1,2,direct);
#endif

  /* Use "fft3d" utility because of data access pattern */
  fft3d((FComplex*)data, xres, yres, 1, direct, "xy");

  /*Demultiplex FTed data back into real and imaginary array */
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
	data[xres*j+i].r /= scale;
	data[xres*j+i].i /= scale;
      }

if(debug)
printf("2D-FFT of Raw Data (scale %f)....\n",scale);

  return(0);  
}

/**************************************************************************/
/* BJM: (1/10/96) Perform 1D-FFT on data in complex array using Numerical */
/* Recipes routine */

int i1dfft(fcomplex data[], int xres, float scale, int direction)
{
  int i;

#ifdef never
  unsigned long int nn[1];
  nn[0] = xres;

  /* Numerical recipes uses unitary offset arrays*/
  nr_fourn((float *)data-1,nn-1,1,direction);
#endif

  /* Use "fft3d" utility because of data access pattern */
  fft3d((FComplex*)data, xres, 1, 1, direction, "x");

  /*Demultiplex FTed data back into real and imaginary array */
  for(i=0;i<xres;i++)
      {
	data[i].r /=scale;
	data[i].i /=scale;
      }

#ifdef never
if(debug)
printf("1D-FFT of Data (scale %f) ....\n",scale);
#endif

  return(0);  

}
  
/**************************************************************************/
/* Calculate magnitude from complex data array and return */
/* pointer to magnitude */
float *mag(fcomplex data[], int xres, int yres)
{
  int i,j;
  float *mg;
  
  if ((mg =(float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for mg.\n");
    }

  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
	mg[j*xres+i] = nr_Cabs(data[j*xres+i]);

if(debug)
printf("Taking Magnitude of Data....\n");

  return(mg);  
}

/**************************************************************************/
/* Calculate magnitude from complex multi-receiver data array and return */
/* pointer to magnitude */
float *pamag(fcomplex **pdata,int numrecv, int xres, int yres)
{
  int i,j, k;
  float *mg;
  float M;
  float sqrsum, sum;
  
  if ((mg =(float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for mg.\n");
    }

  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
	sqrsum = 0;
	sum = 0;
	for (k=0;k<numrecv;k++)
	  {
	    M = nr_Cabs(pdata[k][j*xres+i]);
	    sqrsum += M*M;
	    sum += M;
	  }
	mg[j*xres+i] = sqrsum/sum;
      }
  
  return(mg);  
}

/**************************************************************************/
/* Write out data file, first casting data into short integer format */
/* Use a header format that is compatible with Signa 5.x data but */
/* only 80 bytes long */
int writeimage(float image[], int xres, int yres,char *filename,float
	       sclfctr,float pixoffset,int rep, int blank)
{
  int offset;
  short *simage;
  FILE *fpimage;
  int i,j;
  char magicnum[] = "IMGF";
  int header_length, bits_per_short;
  float max;
  float temp;
  float norm;
  float tmp;
  
  offset = 0;
  header_length = 80;
  bits_per_short = 16;
  max = 0.;
  
  if ((simage =(short *)calloc((size_t)xres*yres,sizeof(short)))==NULL)
    {
      Abort("allocation failure for simage.\n");
    }

  /* BJM: temp fix.  Add blanking of top and bottom of image for */
  /*      baseline problem with fast receiver.... */
  for(j=0; j<yres; j++) {
    for(i=0; i<xres; i++)
    {
      if( (j< blank) || (j>=yres-blank) )
        image[j*xres + i] = 0.0;

      if ((temp = fabs(image[j*xres + i])) > max)
        max = temp;
    }
  }

  max = sclfctr*max + pixoffset;
  
  if (max>MAXSHORT)
    norm = (float)MAXSHORT/max;
  else if (max < 1.0) {
    sclfctr = 1000;
    norm = 1.;
  }
  
  else
    norm = 1.;
  
if(pixoffset != 0.)
  Message("# Pixel Offset (account for negative values) = %f\n",pixoffset);
  Message("# Max Pixel Value = %f\n",max);

/* autoscaling if necessary */
if(norm != 1.){
  Message("# Must AUTO Scale to fit result into short array\n");
  Message("# SHORT scale factor = %f\n",norm);
}
      
  for(j=0; j<yres; j++)
    for(i=0; i<xres; i++)
      {
	tmp = (sclfctr*image[j*xres + i]+pixoffset)*norm;
	simage[j*xres + i] = (short)(((tmp>0.)?0.5:-0.5)+tmp);
      }
  
  if ((fpimage = fopen(filename,"wb+"))!=NULL)
    {
      fseek(fpimage, (long) offset, (int) 0);
      fwrite(magicnum,sizeof(char),4,fpimage);
      fwrite(&header_length,sizeof(int),1,fpimage);
      fwrite((int *)(&xres),sizeof(int),1,fpimage);
      fwrite((int *)(&yres),sizeof(int),1,fpimage);
      fwrite(&bits_per_short,sizeof(int),1,fpimage);
      fwrite(&sclfctr,sizeof(float),1,fpimage);
      fseek(fpimage, (long) header_length, (int) 0);
      fwrite(simage, sizeof(short),xres*yres, fpimage);
      fclose(fpimage);
    }
  else
    return(1);

  free(simage);

if(debug)
printf("Writing Image Data.....\n"
       "Header Size (bytes) = %d\n"
       "Xres = %d & Yres = %d\n"
       "Auto Scale Factor = %f\n",
       header_length,xres,yres,norm
     );

  return(0);
}

/**************************************************************************/
/* Write out SDT data file, first casting data into short integer format */
/* NO HEADER */
int writeimage_sdt(float image[], int xres, int yres,char
*filename,float sclfctr,float pixoffset,int rep, int frame, int slice,
  int numslice, FILE *fpsdt, int blank) 
{
  int offset = 0;
  short *sh_image;
  int i,j;
  int bits_per_short;
  float max;
  float temp;
  float norm;
  float tmp;
  bits_per_short = 16;
  max = 0.0;
  
/* short array for writing data to disk */
  if ((sh_image =(short *)calloc((size_t)xres*yres,sizeof(short)))==NULL)
    {
      Abort("allocation failure for simage.\n");
    }

  /* add blanking of top and bottom of image for baseline problem */
  for(j=0+blank; j<yres-blank; j++) {
    for(i=0; i<xres; i++)
    {
      if( (j<= blank) || (j>=yres-blank) )
        image[j*xres + i] = 0.0;

      if ((temp = fabs(image[j*xres + i])) > max)
        max = temp;
    }
  }
  
  max = sclfctr*max + pixoffset;
  
  if (max>MAXSHORT)
    norm = (float)MAXSHORT/max;
  else if (max < 1.0) {
    sclfctr = 1000;
    norm = 1.;
  }
  
  else
    norm = 1.;
  
  for(j=0; j<yres; j++)
    for(i=0; i<xres; i++)
      {
	tmp = (sclfctr*image[j*xres + i]+pixoffset)*norm;
	sh_image[j*xres + i] = (short)(((tmp>0.)?0.5:-0.5)+tmp);
      }

  /* figure out offset in file */
  offset = (frame)*slice + frame*numslice*rep;      
 
  Message("# Max Pixel Value for Slice %d of "
                "first image in .sdt file = %f\n",slice,max);
  
  if(max == 0.0) {
    Message("Stimulate Offset = %d, sl = %d, fram =%d, nsl =  %d, srep = %d\n",
          offset,slice,frame,numslice,rep);
    Message("Rep = %d && Max = %f\n",rep,max);
  }
  
/* write stimualte file type - no header */ 
      rewind(fpsdt);  
      fseek(fpsdt, (long) offset, 0);
      fwrite(sh_image, sizeof(short),xres*yres, fpsdt);
  
/* BJM 1/17/97: this was causing a seg. fault when compiled under */
/* Solaris and no hamming filter is applied (cause unknown) */
/*  free(sh_image);*/

if(debug)
printf("Writing SDT Image Data Format.....\n\
       Offset (bytes) = %d\n\
       Xres = %d & Yres = %d\n\
       Auto Scale Factor = %f\n\
       Slice # = %d.\n\
       Rep # = %d\n",
       offset,xres,yres,norm,numslice,rep
     );

  return(0);
}

#ifdef UNDEF 
/* This routine doesn't work (yet) so dont even compile */
/**************************************************************************/
/* Write out data file, first casting data into short integer format */
/* Use a header format that is compatible with Signa 5.x data */
/* including exam, series, and image header.*/
int writesigna(float image[], int xres, int yres,char *filename, float sclfctr, EXAMDATATYPE examhead, SERIESDATATYPE serieshead, MRIMAGEDATATYPE imagehead, float pixoffset)
{
  int offset;
  short *simage;
  FILE *fpimage;
  int i,j;
  ImgHdr head_data;
/*  char magicnum[] = "IMGF";*/
/*  char magicnum[] = (char *)IMG_MAGIC;*/
  char *iheader;
  float max;
  float temp;
  float norm;
  float tmp;
  
  head_data.img_magic = IMG_MAGIC;
/*  strcpy(head_data.img_magic,magicnum);*/
  head_data.img_hdr_length = sizeof(ImgHdr) + RDB_EXAMDATATYPE_SIZE
    + RDB_SERIESDATATYPE_SIZE + RDB_MRIMAGEDATATYPE_SIZE;
  head_data.img_width = xres;
  head_data.img_height = yres;
  head_data.img_depth = 16;
  head_data.img_p_exam = sizeof(ImgHdr);
  head_data.img_l_exam = RDB_EXAMDATATYPE_SIZE;
  head_data.img_p_series = sizeof(ImgHdr) + RDB_EXAMDATATYPE_SIZE;
  head_data.img_l_series = RDB_SERIESDATATYPE_SIZE;
  head_data.img_p_image = sizeof(ImgHdr) + RDB_EXAMDATATYPE_SIZE +
    RDB_SERIESDATATYPE_SIZE;
  head_data.img_l_image = RDB_MRIMAGEDATATYPE_SIZE;
  head_data.img_compress = 1; /* should be 1 */
  head_data.img_dwindow = 0;
  head_data.img_dlevel = 0;
  head_data.img_bgshade = 0;
  head_data.img_ovrflow = 32767;
  head_data.img_undflow = -32768;
  head_data.img_top_offset = 0;
  head_data.img_bot_offset = 0;
  head_data.img_version = IMG_HDR_VERSION; /* IMG_HDR_VERSION */
  head_data.img_checksum = 0;
  head_data.img_p_id = 0;
  head_data.img_l_id = 0;
  head_data.img_p_unpack = 0;
  head_data.img_l_unpack = 0;
  head_data.img_p_compress = 0;
  head_data.img_l_compresss = 0;
  head_data.img_p_histo = 0;
  head_data.img_l_histo = 0;
  head_data.img_p_text = 0;
  head_data.img_l_text = 0;
  head_data.img_p_graphics = 0;
  head_data.img_l_graphics = 0;
  head_data.img_p_dbHdr = 0;
  head_data.img_l_dbHdr = 0;
  head_data.img_levelOffset = 0;
  head_data.img_p_user = 0;
  head_data.img_l_user = 0;
  head_data.img_p_suite = 0;
  head_data.img_l_suite = 0;

  if ((iheader =(char *)calloc(head_data.img_hdr_length,
                                   sizeof(char)))==NULL)
	{
	  Abort("Allocation failure for image header.\n");
	}

  offset = 0;
/*  header_length = 50;
  bits_per_short = 16;*/
  max = 0.;

  memcpy(iheader,&head_data,sizeof(ImgHdr));
  /*  EXAM_43(iheader+head_data.img_p_exam,&examhead,0);
  SERIES_43(iheader+head_data.img_p_series,&serieshead,0);
  IMAGE_43(iheader+head_data.img_p_image,&imagehead,0);
  */
  
  if ((simage =(short *)calloc((size_t)xres*yres,sizeof(short)))==NULL)
    {
      Abort("allocation failure for .\n");
    }

  for(j=0; j<yres; j++)
    for(i=0; i<xres; i++)
      if ((temp = fabs(image[j*xres + i])) > max)
        max = temp;
  
  max = sclfctr*max + pixoffset;
  
  if (max>MAXSHORT)
    norm = (float)MAXSHORT/max;
  else
    norm = 1.;

  Message("pixoffset = %f\n",pixoffset);
  Message("max = %f\n",max);
  Message("norm = %f\n",norm);  
      
  for(j=0; j<yres; j++)
    for(i=0; i<xres; i++)
      {
	tmp = (sclfctr*image[j*xres + i]+pixoffset)*norm;
	simage[j*xres + i] = (short)(((tmp>0.)?0.5:-0.5)+tmp);
      }
  
  if ((fpimage = fopen(filename,"wb+"))!=NULL)
    {
      fseek(fpimage, (long) offset, (int) 0);
/*      fwrite(magicnum,sizeof(char),4,fpimage);
      fwrite(&header_length,sizeof(int),1,fpimage);
      fwrite((int *)(&xres),sizeof(int),1,fpimage);
      fwrite((int *)(&yres),sizeof(int),1,fpimage);
      fwrite(&bits_per_short,sizeof(int),1,fpimage);
      fwrite(&sclfctr,sizeof(float),1,fpimage);*/
      fwrite(iheader,head_data.img_hdr_length,1,fpimage);      
      fseek(fpimage, (long) head_data.img_hdr_length, (int) 0);
      fwrite(simage, sizeof(short),xres*yres, fpimage);
      fclose(fpimage);
    }
  else
    return(1);

  free(simage);
  free(iheader);

  return(0);
}
#endif /* UNDEF */

/**************************************************************************/
/* Zero pad data along y axis from yres to rcyres points */
/* A new complex data array is created pad, then pdata are */
/* set to point to that array */
/* BJM: pads aysmetrically to account for fract. Ky scanning */ 

int pady(fcomplex *pdata[], int xres, int rcyres, int yres, int symmetric)
{
  int i,j;
  int padl;
  fcomplex *pad;
  

  if ((pad =(fcomplex *)calloc((size_t)xres*rcyres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for pad.\n");
    }

   /* how to pad */
   if(symmetric == 1)
     padl = (int)(rcyres-yres)/2.;
   else
     padl = 0;
  
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
	pad[(j+padl)*xres+i] = (*pdata)[j*xres+i];

  /* Since we no longer need the space for *pdata we can free it */
  free(*pdata);
  
  /*Set the value point to by pdata pad*/
  *pdata = pad;

if(debug)
printf("Zero Padding Data along Y\n"
       "Symmetric Padding? (1 = yes) = %d\n",
       symmetric
     );

  return(0);
  
}
/**************************************************************************/
/* Zero pad data along x axis from yres to rcyres points */
/* A new complex data array is created pad, then pdata
 are set to point to that array */
/* BJM: pads symmetrically or assymetrically to account for fract. FOV imaging */

int padx(fcomplex *pdata[], int rcxres, int xres, int yres, int symmetric)
{
  int i,j;
  int padl;
  fcomplex *pad;
  
  if ((pad = (fcomplex *)calloc((size_t)rcxres*yres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for pad.\n");
    }

/* pad symmetrically or asymmetrically */
  if(symmetric == 1)
    padl = (int)(rcxres - xres)/2.;
  else 
    padl = 0;

  for(j=0;j<yres;j++)
    for(i=0;i<xres;i++)
       pad[j*rcxres+i+padl] = (*pdata)[j*xres+i];
  
  /* Since we no longer need the space for *pdata we can free it */
  free(*pdata);
  
  /*Set the value point to by pdata pad*/
  *pdata = pad;

if(debug)
printf("Zero Padding Data along X\n"
       "Symmetric Padding? (1 = yes) = %d\n",
       symmetric
     );

  return(0);
  
}

/**************************************************************************/
/*Get raw data filename from command line */
int readcl(int numarg,char **pstring, char filename[])
{

if (numarg !=1)
{
  pstring++;
  while (*pstring != NULL)
  {
    if (strcmp("-f",*pstring)==0)
    {
      pstring++;
      strcpy(filename,*pstring);
      pstring++;
    }
    else if (strcmp("-h",*pstring)==0)
    {
      printf("Command Line Format.\n");
      printf("myrecon  -f <raw data filename> [optional switches]\n");
      pstring++;
      exit(0);
    }
    else pstring++;

  }
}

 return(0);
}

/**************************************************************************/
/* Return complex-difference magnitude from pair of complex array */

float *cd(fcomplex z1[],fcomplex z2[],int xres,int yres)
{
  int i,j;
  float *comp_diff;

  if ((comp_diff = (float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for comp_diff.\n");
    }

  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
	comp_diff[j*xres+i]=nr_Cabs(nr_Csub(z1[j*xres+i],z2[j*xres+i]));
  
  return(comp_diff);
  
}
/**************************************************************************/
/* Return complex-difference magnitude from pair of complex */
/* multi-receiver data array */

float *pacd(fcomplex **z1,fcomplex **z2,int numrecv,int xres,int yres)
{
  int i,j,k;
  float *comp_diff;
  float sqrsum, sum;
  float cd1r,cd1i,cd2r,cd2i,cdiffr,cdiffi,cd2temp;
  int index;
  
  if ((comp_diff = (float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for comp_diff.\n");
    }


  for(j=0;j<yres;j++)
    for(i=0;i<xres;i++)
      {
	sqrsum = 0.;
	sum = 0.;
        index = j*xres + i;
	for (k=0;k<numrecv;k++)
	  {
            cd1r = z1[k][index].r;
            cd1i = z1[k][index].i;
            cd2r = z2[k][index].r;
            cd2i = z2[k][index].i;
            cdiffr = cd1r - cd2r;
            cdiffi = cd1i - cd2i;
            cd2temp = cdiffr*cdiffr + cdiffi*cdiffi;
            sqrsum += cd2temp;
            sum += sqrt(cd2temp);
            /*    CD = nr_Cabs(nr_Csub(z1[k][j*xres+i],z2[k][j*xres+i]));
	    sqrsum += CD*CD;
	    sum += CD;*/
          }
	comp_diff[j*xres+i] =sqrsum/sum;
/*        *comp_diff++ =sqrsum/sum;*/

      }
  return(comp_diff);
}

/**************************************************************************/
/* Return component of complex-difference vector that is perpendicular */
/* to the background phase */ 

float *perp_cd(fcomplex z1[],fcomplex z2[],int xres,int yres)
{
  int i,j;
  float *perp_comp_diff;
  fcomplex cdiff;		/* original complex diff. vector */
  float theta;			/* background phase */
  
  if ((perp_comp_diff = (float
			 *)calloc((size_t)xres*yres,sizeof(float)))==NULL) 
    {
      Abort("allocation failure for perp_comp_diff.\n");
    }

  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
	cdiff = nr_Csub(z1[j*xres+i],z2[j*xres+i]);
	theta = Carg(nr_Cmul(z1[j*xres+i],z2[j*xres+i]))/2.0;
	perp_comp_diff[j*xres+i]=fabs(-cdiff.r*sin(theta)+cdiff.i*cos(theta));
      }
  
  
  return(perp_comp_diff);
  
}
/**************************************************************************/
/* Return the background phase */ 

float *bk_phase(fcomplex z1[],fcomplex z2[],int xres,int yres)
{
  int i,j;
  float *bkgnd_ph;
  
  if ((bkgnd_ph = (float
			 *)calloc((size_t)xres*yres,sizeof(float)))==NULL) 
    {
      Abort("allocation failure for bkgnd array.\n");
    }

  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
/*      bkgnd_ph[j*xres+i] = */
/*      Carg(nr_Cmul(z1[j*xres+i],z2[j*xres+i]))/2.0;*/
      bkgnd_ph[j*xres+i] =
	Carg(nr_Csqrt(nr_Cmul(z1[j*xres+i],z2[j*xres+i])));
  
  
  return(bkgnd_ph);
  
}

/**************************************************************************/
/* Return phase-difference from pair of complex arrays*/

float *pd(fcomplex z1[],fcomplex z2[],int xres,int yres)
{
  int i,j;
  float *phase_diff;
  
  if ((phase_diff = (float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for phase_diff.\n");
    }
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
	phase_diff[j*xres+i] = Carg(nr_Cmul(z1[j*xres+i],nr_Conjg(z2[j*xres+i])));
  
  return(phase_diff);
  
}

/**************************************************************************/
/* Return phase-difference from pair of mult-coil complex arrays*/

float *papd(fcomplex **z1,fcomplex **z2,int numrecv, int xres,int yres)
{
  int i,j,k;
  float *phase_diff;
  float  Ar,Ai;  
  float sumr, sumi;
  int index;
  float pd1r,pd1i,pd2r,pd2i;
  
  if ((phase_diff = (float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for phase_diff.\n");
    }
  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
        index = j*xres + i;
	sumr = 0.;
	sumi = 0.;
	for (k=0;k<numrecv;k++)
	  {
            pd1r = z1[k][index].r;
            pd1i = z1[k][index].i;
            pd2r = z2[k][index].r;
            pd2i = z2[k][index].i;
            Ar = pd1r*pd2r + pd1i*pd2i;
            Ai = pd1i*pd2r - pd1r*pd2i;
/*	    A = nr_Cmul(z1[k][j*xres+i],nr_Conjg(z2[k][j*xres+i]));
	    sum = nr_Cadd(sum,A);
*/
            sumr += Ar;
            sumi += Ai;
	  }

/*	phase_diff[j*xres+i] = sum;*/
        phase_diff[j*xres+i] = atan2(sumi,sumr);
      }  
  return(phase_diff);
}
/**************************************************************************/
/* Compute that phase angle for a given complex value */

float Carg(fcomplex z)
{
  float ans;
  float x,y;
  
  x = z.r;
  y = z.i;
  
  if ((x==0.)&&(y==0.))
    ans = 0.;
  else
    ans = (float)atan2(z.i,z.r); 
  
  return ans;
  
}

/**************************************************************************/
/* Calculate average value for a list of image arrays */
/* A pointer to the average image is returned */
float *avg(float **list,int listlength, int xres, int yres)
{
  int i,j, k;
  float *ans;
  
  if ((ans =(float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for for avg.\n");
    }

  for(i=0;i<xres;i++)
    for(j=0;j<yres;j++)
      {
	for(k=0;k<listlength;k++)
	  ans[j*xres+i] += list[k][j*xres+i];
	ans[j*xres+i] /= listlength;
      }
  
  return(ans);  
}

/*int *rot90(float image[],int *pxres, int *pyres)
{
  int i,j;
  int inew, jnew, xresd2, yresd2;

  xresd2 = *pxres/2;
  yresd2 = *pyres/2;
  newxres = *pyres;
  newyres = *pxres;
  
  for (i=0;i<*pxres;i++)
    for (j=0;j<*pyres;j+)
      {
        inew = -j + xresd2 + yresd2;
        jnew = i + yresd2 - xresd2;
        temp = image[j*xres +i];
        
      }
  

  return(1);
  
 }
*/

int dorot(fcomplex data[],int xres,int yres,float rot)
{
  fcomplex crot;
  fcomplex temp;
  
  int i,j;

  crot = nr_Complex(cos(rot),sin(rot));

  for(j=0;j<yres;j++)
    for(i=0;i<xres;i++)
      {
	temp = data[j*xres+i];
	data[j*xres+i] = nr_Cmul(temp,crot);
      }

  return(0);
}

/**************************************************************************/
/* Return log (1 + raw) */

float *lograw(fcomplex z[],int xres,int yres)
{
  int i,j;
  float *raw;

  if ((raw = (float *)calloc((size_t)xres*yres,sizeof(float)))==NULL)
    {
      Abort("allocation failure for log raw array.\n");
    }


  for(j=0;j<yres;j++)
    for(i=0;i<xres;i++)
	raw[j*xres+i]=log(1. + nr_Cabs(z[j*xres+i]));

  
  return(raw);
  
}

/**************************************************************************/
/* flip raw data about kx = 0 */

int fliprawx(fcomplex z[],int xres,int yres)
{
  int i,j;
  fcomplex *refl;

  if ((refl = (fcomplex *)calloc((size_t)xres*yres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for reflection array.\n");
    }

/* fill holding array */
 for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
	refl[j*xres+i].r = z[(j*xres)+i].r;      
	refl[j*xres+i].i = z[(j*xres)+i].i;
      }

/* this flips array */
  for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
	z[j*xres+i].r = refl[(j+1)*(xres) - (i+1)].r;      
	z[j*xres+i].i = refl[(j+1)*(xres) - (i+1)].i;
      }

  free(refl);
  return(0);
  
}

/**************************************************************************/
/* flip raw data about ky = 0 */

int fliprawy(fcomplex z[],int xres,int yres)
{
  int i,j;
  fcomplex *refl;

  if ((refl = (fcomplex *)calloc((size_t)xres*yres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for reflection array.\n");
    }

/* fill holding array */
 for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
	refl[j*xres+i].r = z[(j*xres)+i].r;      
	refl[j*xres+i].i = z[(j*xres)+i].i;
      }
  
/* this does flipping */
  for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
	z[j*xres+i].r = refl[(yres*xres) - (j+1)*xres + i].r;      
	z[j*xres+i].i = refl[(yres*xres) - (j+1)*xres + i].i;
      }
  free(refl);
  
  return(0);  
}

/**************************************************************************/
/* Shift image a specified number of pixels in the y direction - apply in */ 
/* k-space - uses shift theorem */

int pixshifty(fcomplex data[],int xres,int yres, int shift)
{
  int i,j;
  fcomplex temp;  /* temporary storage of rotation values */
  fcomplex crot; 
  
  for(i=0;i<xres;i++) {
    for(j=0;j<yres;j++)
      {
      crot = nr_Complex(cos(2.0*M_PI*(float)(shift*j)/(float)yres),sin(2.0*M_PI*(float)(shift*j)/(float)yres));
      temp = data[j*xres+i];
      data[j*xres+i] = nr_Cmul(temp,crot);    
    }
  }
  return(0);
  
}

/**************************************************************************/
/* Shift image a specified number of pixels in the x direction - apply in */ 
/* k-space - uses shift theorem */

int pixshiftx(fcomplex data[],int xres,int yres, int shift)
{
  int i,j;
  fcomplex temp;  /* temporary storage of rotation values */
  fcomplex crot; 
  

  for(j=0;j<yres;j++) {
    for(i=0;i<xres;i++)     
      {
      crot = nr_Complex(cos(2.0*M_PI*(float)(shift*j)/(float)yres),sin(2.0*M_PI*(float)(shift*j)/(float)yres));
      temp = data[j*xres+i];
      data[j*xres+i] = nr_Cmul(temp,crot);    
    }
  }
  return(0);
  
}

/**************************************************************************/
/* average raw data together */

fcomplex *avg_data(fcomplex z1[],fcomplex z2[],int xres,int yres)
{
  int i,j;

/* avg. data and put into first array passed */
 for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
	z1[j*xres+i].r = (z1[(j*xres)+i].r + z2[(j*xres)+i].r)/2.0;      
	z1[j*xres+i].i = (z1[(j*xres)+i].i + z2[(j*xres)+i].i)/2.0;
      }
  
  return(z1);  
}

/**************************************************************************/
/* average raw data together */

fcomplex *parse_data(fcomplex z1[],fcomplex z2[],int xres,int yres)
{
  int i,j;

/* parse data and put into first array passed */
 for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
      if(j%2) {
	z1[j*xres+i].r = z2[(j*xres)+i].r;      
	z1[j*xres+i].i = z2[(j*xres)+i].i;
      }      
    }
  
  return(z1);  
}

/**************************************************************************/
/* BJM: 12/2/97: modification -                                           */
/* added passing of rowflip.param for multi-shot compatibility            */
/* NOTE: if rflp.flag == 0, function assumes single shot and every        */
/* other line will be flipped by default....                              */
int fliprowx(fcomplex z[],int xres,int yres, int rep, int numlv,
             int *rwflip, int rflp_flag)
{
  int i,j, index = 0;
  fcomplex *refl;

  if(rflp_flag) {
    if (debug) Message("# Performing Row Flipping of EPI Data according to ");
    if (debug) Message("# rowflip.param file.....\n");
  } else {
    if (debug) Message("# Manually Performing Row Flipping of EPI Data\n");
  }

  if ((refl = (fcomplex *)calloc((size_t)xres*yres,sizeof(fcomplex)))==NULL)
    {
      Abort("allocation failure for holding array.\n");
    }

/* fill holding array */
 for(j=0;j<yres;j++)
    for(i=0;i<xres;i++) {
	refl[j*xres+i].r = z[(j*xres)+i].r;      
	refl[j*xres+i].i = z[(j*xres)+i].i;
      }
  
/* this does flipping - every other line */
  for(j=0;j<yres;j++)
      for(i=0;i<xres;i++) {
        if(rflp_flag) {
           if( rwflip[j] == 1) {
	      z[j*xres+i].r = refl[(j+1)*(xres) - (i+1)].r;      
	      z[j*xres+i].i = refl[(j+1)*(xres) - (i+1)].i;
           } /* flip lines specified by rowflip.param */
        } else {
            if(numlv > 1) { 
              if((j/numlv)%2 == 0) {
	        z[j*xres+i].r = refl[(j+1)*(xres) - (i+1)].r;      
	        z[j*xres+i].i = refl[(j+1)*(xres) - (i+1)].i;
              }  /* flip interleaves if no rowflip assuming ileavs reordered */
          } else {
              if(j%2 == 0) {
	         z[j*xres+i].r = refl[(j+1)*(xres) - (i+1)].r;      
	         z[j*xres+i].i = refl[(j+1)*(xres) - (i+1)].i;
              } /* flips every other line for single shot */
            }
        }
      }
 
  free(refl);
  
  return(0);  
}

/**************************************************************************/
/* BJM: 12/2/97: addition -                                               */
/* Since NOPROC is used for epibold scans, shots are stored as they are   */
/* collected and they need to be reordered before flipping the data.      */
/* This routine is a modifcation of a routine written by Karl Vigen.      */
int reorder_ileaves(fcomplex z[],int xres,int yres, int ileaves)
{
  int j,k,m;         /* counting variables  */
  fcomplex *reord;   /* temporary reordering array   */
  int vpsh;          /* vpsh - views per shot (as opposed to vps) */
  
/* allocate memory for reorder array */
  if ((reord = (fcomplex *)calloc((size_t)xres*yres,sizeof(fcomplex)))
      == NULL)
    {
      Abort("Allocation failure for reordering array.\n");
    }

/* #views per shot */
  vpsh = yres/ileaves;

/* fill array with unordered data*/
  for (j=0;j<yres;j++)
    for (k=0;k<xres;k++)
      {
	reord[j*xres+k].r = z[j*xres+k].r;
	reord[j*xres+k].i = z[j*xres+k].i;
      }
  
/* do the reordering by skipping over vpsh */
  for (j=0;j<vpsh;j++)
    for (k=0;k<ileaves;k++)
      for (m=0;m<xres;m++)
	{
	  z[(j*ileaves+k)*xres+m].r = reord[(k*vpsh+j)*xres+m].r;
	  z[(j*ileaves+k)*xres+m].i = reord[(k*vpsh+j)*xres+m].i;
	}

if(debug)
printf("Reordering Interleaves for Multi-Shot EPI\n"
       "Views Per Shot = %d\n",
       vpsh
     );

/* clean up */
  free(reord);
  return(0);

} /* end reorder_ileaves() */

/*************************************************************************/
/* BJM rotate image by increment of 90,180,270  */
/************************************************************************/
int rotate_image(float data[],int xres, int yres, float theta)
{
  int i,j;
  float cs, sn;
  float xcent,ycent;
  double xrot, yrot;
  float **hold;
  
 /* allocate memory */
  hold = nr_matrix(0,xres-1,0,yres-1);

/* Rotation Values */
  cs = cos(theta);
  sn = sin(theta);
  xcent = xres/2.0-1.;
  ycent = yres/2.0-1.;
  
/* copy data */ 
  for(j=0;j<yres;j++) 
    for(i=0;i<xres;i++) {
      hold[j][i] = data[j*xres+i];    
    }

/* rotate image */
  for(j=0;j<yres;j++) 
    for(i=0;i<xres;i++) {
      xrot=(i-xcent)*cs-(j-ycent)*sn + xcent;
      yrot=(j-ycent)*cs+(i-xcent)*sn + xcent;

/* boundary protection */
	if (yrot<0) yrot = 0;
	if (xrot<0) xrot = 0; 
	if (yrot>yres-1) yrot = yres-1;
	if (xrot>xres-1) xrot = xres-1;

/* rotate image */
      data[j*xres+i] = hold[(int)yrot][(int)xrot];	
    }

/* free memory used */
  nr_free_matrix(hold,0,xres-1,0,yres-1);

  return(0);
  
} /* end rotate_image */

/* Byte-swapping code for Linux */
void swap16(void* p)
{
  ((unsigned char*)p)[0]^=((unsigned char*)p)[1];
  ((unsigned char*)p)[1]^=((unsigned char*)p)[0];
  ((unsigned char*)p)[0]^=((unsigned char*)p)[1];
} /* end swap16 */

void swap32(void* p)
{
  swap16(p);
  swap16((short*)p+1);
  ((unsigned short*)p)[0]^=((unsigned short*)p)[1];
  ((unsigned short*)p)[1]^=((unsigned short*)p)[0];
  ((unsigned short*)p)[0]^=((unsigned short*)p)[1];
} /* end swap32 */

