/* lbfgs.f -- translated by f2c (version of 3 February 1990  3:36:42).
   You must link the resulting object file with the libraries:
	-lf77 -li77 -lm -lc   (in that order)
*/

#include <stdio.h>
#include <time.h>
#include <math.h>
#include <string.h>

/* #include "f2c.h" */

/* Some things from f2c.h */
typedef int logical;
typedef short ftnlen;
typedef struct
{       short oerr;
        short ounit;
        char *ofnm;
        ftnlen ofnmlen;
        char *osta;
        char *oacc;
        char *ofm;
        short orl;
        char *oblnk;
} olist;
typedef struct
{       short cierr;
        short ciunit;
        short ciend;
        char *cifmt;
        short cirec;
} cilist;
#define TRUE_ (1)
#define FALSE_ (0)
#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))

/* Table of constant values */

static double c_b9 = 0.;
static int c__1 = 1;
static int c__9 = 9;
static int c__11 = 11;
static int c__3 = 3;
static double c_b275 = .001;
static double c_b276 = .9;
static double c_b277 = .1;
static int c__5 = 5;

/* Substitute routines for things found in Fortran libs */
int lcl_s_cmp( char* s1, char* s2, long l1, long l2 ) 
{
  return strncmp( s1, s2, ( l1>l2 ? l2 : l1 ) );
}

int lcl_s_copy(char *s1, char *s2, long l1, long l2)
{
  strncpy(s1, s2, ( l1>l2 ? l2 : l1 ));
  if (l1>l2) s1[l2]= '\0';
  return 0;
}

/* ================    L-BFGS-B (version 2.3)   ========================== */
/* Subroutine */ int setulb(int *n, int *m, double *x, 
	double *l, double *u, int *nbd, double *f, double 
	*g, double *factr, double *pgtol, double *wa, int *
	iwa, char *task, int *iprint, char *csave, logical *lsave, 
	int *isave, double *dsave, ftnlen task_len, ftnlen csave_len)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int lsnd, l1, l2, l3, ld, lr, lt;
    extern /* Subroutine */ int mainlb_(int *, int *, double *, 
	    double *, double *, int *, double *, double *,
	     double *, double *, double *, double *, 
	    double *, double *, double *, double *, 
	    double *, double *, double *, double *, 
	    double *, double *, int *, int *, int *, char 
	    *, int *, char *, logical *, int *, double *, ftnlen, 
	    ftnlen);
    int lz, lwa, lwn, lss, lws, lwt, lsy, lwy;

    /* Parameter adjustments */
    --x;
    --l;
    --u;
    --nbd;
    --g;
    --wa;
    --iwa;
    --lsave;
    --isave;
    --dsave;

    /* Function Body */
/*     ************ */

/*     Subroutine setulb */

/*     This subroutine partitions the working arrays wa and iwa, and */
/*       then uses the limited memory BFGS method to solve the bound */
/*       constrained optimization problem by calling mainlb. */
/*       (The direct method will be used in the subspace minimization.) */


/*     n is an int variable. */
/*       On entry n is the dimension of the problem. */
/*       On exit n is unchanged. */

/*     m is an int variable. */
/*       On entry m is the maximum number of variable metric corrections 
*/
/*         used to define the limited memory matrix. */
/*       On exit m is unchanged. */

/*     x is a double precision array of dimension n. */
/*       On entry x is an approximation to the solution. */
/*       On exit x is the current approximation. */

/*     l is a double precision array of dimension n. */
/*       On entry l is the lower bound on x. */
/*       On exit l is unchanged. */

/*     u is a double precision array of dimension n. */
/*       On entry u is the upper bound on x. */
/*       On exit u is unchanged. */

/*     nbd is an int array of dimension n. */
/*       On entry nbd represents the type of bounds imposed on the */
/*         variables, and must be specified as follows: */
/*         nbd(i)=0 if x(i) is unbounded, */
/*                1 if x(i) has only a lower bound, */
/*                2 if x(i) has both lower and upper bounds, and */
/*                3 if x(i) has only an upper bound. */
/*       On exit nbd is unchanged. */

/*     f is a double precision variable. */
/*       On first entry f is unspecified. */
/*       On final exit f is the value of the function at x. */

/*     g is a double precision array of dimension n. */
/*       On first entry g is unspecified. */
/*       On final exit g is the value of the gradient at x. */

/*     factr is a double precision variable. */
/*       On entry factr >= 0 is specified by the user.  The iteration */
/*         will stop when */

/*         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch */

/*         where epsmch is the machine precision, which is automatically 
*/
/*         generated by the code. Typical values for factr: 1.d+12 for */
/*         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely 
*/
/*         high accuracy. */
/*       On exit factr is unchanged. */

/*     pgtol is a double precision variable. */
/*       On entry pgtol >= 0 is specified by the user.  The iteration */
/*         will stop when */

/*                 max{|proj g_i | i = 1, ..., n} <= pgtol */

/*         where pg_i is the ith component of the projected gradient. */
/*       On exit pgtol is unchanged. */

/*     wa is a double precision working array of length */
/*       (2mmax + 4)nmax + 11mmax^2 + 8mmax. */

/*     iwa is an int working array of length 3nmax. */

/*     task is a working string of characters of length 60 indicating */
/*       the current job when entering and quitting this subroutine. */

/*     iprint is an int variable that must be set by the user. */
/*       It controls the frequency and type of output generated: */
/*        iprint<0    no output is generated; */
/*        iprint=0    print only one line at the last iteration; */
/*        0<iprint<99 print also f and |proj g| every iprint iterations; 
*/
/*        iprint=99   print details of every iteration except n-vectors; 
*/
/*        iprint=100  print also the changes of active set and final x; */

/*        iprint>100  print details of every iteration including x and g; 
*/
/*       When iprint > 0, the file iterate.dat will be created to */
/*                        summarize the iteration. */

/*     csave is a working string of characters of length 60. */

/*     lsave is a logical working array of dimension 4. */
/*       On exit with 'task' = NEW_X, the following information is */
/*                                                             available: 
*/
/*         If lsave(1) = .true. then  the initial X has been replaced by 
*/
/*                                    its projection in the feasible set; 
*/
/*         If lsave(2) = .true. then  the problem is constrained; */
/*         If lsave(3) = .true. then  each variable has upper and lower */

/*                                    bounds; */

/*     isave is an int working array of dimension 44. */
/*       On exit with 'task' = NEW_X, the following information is */
/*                                                             available: 
*/
/*         isave(22) = the total number of intervals explored in the */
/*                         search of Cauchy points; */
/*         isave(26) = the total number of skipped BFGS updates before */
/*                         the current iteration; */
/*         isave(30) = the number of current iteration; */
/*         isave(31) = the total number of BFGS updates prior the current 
*/
/*                         iteration; */
/*         isave(33) = the number of intervals explored in the search of 
*/
/*                         Cauchy point in the current iteration; */
/*         isave(34) = the total number of function and gradient */
/*                         evaluations; */
/*         isave(36) = the number of function value or gradient */
/*                         evaluations in the current iteration; */
/*         if isave(37) = 0  then the subspace argmin is within the box; 
*/
/*         if isave(37) = 1  then the subspace argmin is beyond the box; 
*/
/*         isave(38) = the number of free variables in the current */
/*                         iteration; */
/*         isave(39) = the number of active constraints in the current */
/*                         iteration; */
/*         n + 1 - isave(40) = the number of variables leaving the set of 
*/
/*                           active constraints in the current iteration; 
*/
/*         isave(41) = the number of variables entering the set of active 
*/
/*                         constraints in the current iteration. */

/*     dsave is a double precision working array of dimension 29. */
/*       On exit with 'task' = NEW_X, the following information is */
/*                                                             available: 
*/
/*         dsave(1) = current 'theta' in the BFGS matrix; */
/*         dsave(2) = f(x) in the previous iteration; */
/*         dsave(3) = factr*epsmch; */
/*         dsave(4) = 2-norm of the line search direction vector; */
/*         dsave(5) = the machine precision epsmch generated by the code; 
*/
/*         dsave(7) = the accumulated time spent on searching for */
/*                                                         Cauchy points; 
*/
/*         dsave(8) = the accumulated time spent on */
/*                                                 subspace minimization; 
*/
/*         dsave(9) = the accumulated time spent on line search; */
/*         dsave(11) = the slope of the line search function at */
/*                                  the current point of line search; */
/*         dsave(12) = the maximum relative step length imposed in */
/*                                                           line search; 
*/
/*         dsave(13) = the infinity norm of the projected gradient; */
/*         dsave(14) = the relative step length in the line search; */
/*         dsave(15) = the slope of the line search function at */
/*                                 the starting point of the line search; 
*/
/*         dsave(16) = the square of the 2-norm of the line search */
/*                                                      direction vector. 
*/

/*     Subprograms called: */

/*       L-BFGS-B Library ... mainlb. */


/*     References: */

/*       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited */
/*       memory algorithm for bound constrained optimization'', */
/*       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. */


/*       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a */
/*       limited memory FORTRAN code for solving bound constrained */
/*       optimization problems'', Tech. Report, NAM-11, EECS Department, 
*/
/*       Northwestern University, 1994. */

/*       (Postscript files of these papers are available via anonymous */
/*        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) */

/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision April 1997.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    if (lcl_s_cmp(task, "START", 60L, 5L) == 0) {
	isave[1] = *m * *n;
/* Computing 2nd power */
	i_1 = *m;
	isave[2] = i_1 * i_1;
/* Computing 2nd power */
	i_1 = *m;
	isave[3] = i_1 * i_1 << 2;
	isave[4] = 1;
	isave[5] = isave[4] + isave[1];
	isave[6] = isave[5] + isave[1];
	isave[7] = isave[6] + isave[2];
	isave[8] = isave[7] + isave[2];
	isave[9] = isave[8];
	isave[10] = isave[9] + isave[2];
	isave[11] = isave[10] + isave[3];
	isave[12] = isave[11] + isave[3];
	isave[13] = isave[12] + *n;
	isave[14] = isave[13] + *n;
	isave[15] = isave[14] + *n;
	isave[16] = isave[15] + *n;
    }
    l1 = isave[1];
    l2 = isave[2];
    l3 = isave[3];
    lws = isave[4];
    lwy = isave[5];
    lsy = isave[6];
    lss = isave[7];
    lwt = isave[9];
    lwn = isave[10];
    lsnd = isave[11];
    lz = isave[12];
    lr = isave[13];
    ld = isave[14];
    lt = isave[15];
    lwa = isave[16];
    mainlb_(n, m, &x[1], &l[1], &u[1], &nbd[1], f, &g[1], factr, pgtol, &wa[
	    lws], &wa[lwy], &wa[lsy], &wa[lss], &wa[lwt], &wa[lwn], &wa[lsnd],
	     &wa[lz], &wa[lr], &wa[ld], &wa[lt], &wa[lwa], &iwa[1], &iwa[*n + 
	    1], &iwa[(*n << 1) + 1], task, iprint, csave, &lsave[1], &isave[
	    22], &dsave[1], 60L, 60L);
    return 0;
} /* setulb_ */

/* ======================= The end of setulb ============================= */
/* Subroutine */ int mainlb_(int *n, int *m, double *x, 
	double *l, double *u, int *nbd, double *f, double 
	*g, double *factr, double *pgtol, double *ws, double *
	wy, double *sy, double *ss, double *wt, double *wn, 
	double *snd, double *z, double *r, double *d, 
	double *t, double *wa, int *index, int *iwhere, 
	int *indx2, char *task, int *iprint, char *csave, logical *
	lsave, int *isave, double *dsave, ftnlen task_len, ftnlen 
	csave_len)
{
    /* System generated locals */
    int ws_dim1, ws_offset, wy_dim1, wy_offset, sy_dim1, sy_offset, 
	    ss_dim1, ss_offset, wt_dim1, wt_offset, wn_dim1, wn_offset, 
	    snd_dim1, snd_offset, i_1;
    double d_1, d_2;
    olist o_1;

    /* Local variables */
    int head;
    double fold;
    int nact;
    double ddum;
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    int info;
    double time;
    int nfgv, ifun, iter, nint;
    char word[3];
    double time1, time2;
    int i, iback, k;
    extern /* Subroutine */ int dscal_(int *, double *, double *, 
	    int *);
    double gdold;
    int nfree;
    logical boxed;
    int itail;
    double theta;
    extern /* Subroutine */ int freev_(int *, int *, int *, 
	    int *, int *, int *, int *, logical *, logical *, 
	    logical *, int *, int *), dcopy_(int *, double *, 
	    int *, double *, int *);
    double dnorm;
    extern /* Subroutine */ int timer_(double *), formk_(int *, 
	    int *, int *, int *, int *, int *, int *, 
	    logical *, double *, double *, int *, double *, 
	    double *, double *, double *, int *, int *, 
	    int *);
    int nskip, iword;
    extern /* Subroutine */ int formt_(int *, double *, double *, 
	    double *, int *, double *, int *), subsm_(int 
	    *, int *, int *, int *, double *, double *, 
	    int *, double *, double *, double *, double *,
	     double *, int *, int *, int *, double *, 
	    double *, int *, int *);
    double xstep, stpmx;
    extern /* Subroutine */ int prn1lb_(int *, int *, double *, 
	    double *, double *, int *, int *, double *), 
	    prn2lb_(int *, double *, double *, double *, 
	    int *, int *, int *, int *, int *, double 
	    *, int *, char *, int *, int *, double *, 
	    double *, ftnlen), prn3lb_(int *, double *, 
	    double *, char *, int *, int *, int *, int *, 
	    int *, int *, int *, int *, double *, 
	    double *, int *, char *, int *, double *, 
	    double *, int *, double *, double *, double *,
	     ftnlen, ftnlen);
    double gd, dr, rr;
    int ileave;
    extern /* Subroutine */ int errclb_(int *, int *, double *, 
	    double *, double *, int *, char *, int *, int 
	    *, ftnlen);
    int itfile;
    double cachyt, epsmch;
    logical updatd;
    extern /* Subroutine */ int active_(int *, double *, double *,
	     int *, double *, int *, int *, logical *, 
	    logical *, logical *);
    double sbtime;
    extern /* Subroutine */ int cauchy_(int *, double *, double *,
	     double *, int *, double *, int *, int *, 
	    double *, double *, double *, int *, double *,
	     double *, double *, double *, double *, int *
	    , int *, double *, double *, double *, double 
	    *, int *, int *, double *, int *, double *);
    logical prjctd;
    int iupdat;
    extern double dpmeps_(void);
    logical cnstnd;
    double sbgnrm;
    int nenter;
    double lnscht;
    extern /* Subroutine */ int cmprlb_(int *, int *, double *, 
	    double *, double *, double *, double *, 
	    double *, double *, double *, double *, int *,
	     double *, int *, int *, int *, logical *, 
	    int *), lnsrlb_(int *, double *, double *, 
	    int *, double *, double *, double *, double *,
	     double *, double *, double *, double *, 
	    double *, double *, double *, double *, 
	    double *, double *, double *, int *, int *, 
	    int *, int *, int *, char *, logical *, logical *, 
	    char *, int *, double *, ftnlen, ftnlen), matupd_(int 
	    *, int *, double *, double *, double *, 
	    double *, double *, double *, int *, int *, 
	    int *, int *, double *, double *, double *, 
	    double *, double *);
    int nintol;
    extern /* Subroutine */ int projgr_(int *, double *, double *,
	     int *, double *, double *, double *);
    double dtd;
    int col;
    double tol;
    logical wrk;
    double stp, cpu1, cpu2;


    /* Parameter adjustments */
    --x;
    --l;
    --u;
    --nbd;
    --g;
    ws_dim1 = *n;
    ws_offset = ws_dim1 + 1;
    ws -= ws_offset;
    wy_dim1 = *n;
    wy_offset = wy_dim1 + 1;
    wy -= wy_offset;
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;
    ss_dim1 = *m;
    ss_offset = ss_dim1 + 1;
    ss -= ss_offset;
    wt_dim1 = *m;
    wt_offset = wt_dim1 + 1;
    wt -= wt_offset;
    wn_dim1 = *m << 1;
    wn_offset = wn_dim1 + 1;
    wn -= wn_offset;
    snd_dim1 = *m << 1;
    snd_offset = snd_dim1 + 1;
    snd -= snd_offset;
    --z;
    --r;
    --d;
    --t;
    --wa;
    --index;
    --iwhere;
    --indx2;
    --lsave;
    --isave;
    --dsave;

    /* Function Body */
/*     ************ */

/*     Subroutine mainlb */

/*     This subroutine solves bound constrained optimization problems by 
*/
/*                -1       if x(i) is always free, i.e., no bounds on it. 
*/

/*     indx2 is an int working array of dimension n. */
/*       Within subroutine cauchy, indx2 corresponds to the array iorder. 
*/
/*       In subroutine freev, a list of variables entering and leaving */
/*       the free set is stored in indx2, and it is passed on to */
/*       subroutine formk with this information. */

/*     task is a working string of characters of length 60 indicating */
/*       the current job when entering and leaving this subroutine. */

/*     iprint is an INT variable that must be set by the user. */
/*       It controls the frequency and type of output generated: */
/*        iprint<0    no output is generated; */
/*        iprint=0    print only one line at the last iteration; */
/*        0<iprint<99 print also f and |proj g| every iprint iterations; 
*/
/*        iprint=99   print details of every iteration except n-vectors; 
*/
/*        iprint=100  print also the changes of active set and final x; */

/*        iprint>100  print details of every iteration including x and g; 
*/
/*       When iprint > 0, the file iterate.dat will be created to */
/*                        summarize the iteration. */

/*     csave is a working string of characters of length 60. */

/*     lsave is a logical working array of dimension 4. */

/*     isave is an int working array of dimension 23. */

/*     dsave is a double precision working array of dimension 29. */


/*     Subprograms called */

/*       L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk, */

/*        errclb, prn1lb, prn2lb, prn3lb, active, projgr, */

/*        freev, cmprlb, matupd, formt. */

/*       Minpack2 Library ... timer, dpmeps. */

/*       Linpack Library ... dcopy, ddot. */


/*     References: */

/*       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited */
/*       memory algorithm for bound constrained optimization'', */
/*       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. */


/*       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN */
/*       Subroutines for Large Scale Bound Constrained Optimization'' */
/*       Tech. Report, NAM-11, EECS Department, Northwestern University, 
*/
/*       1994. */

/*       [3] R. Byrd, J. Nocedal and R. Schnabel "Representations of */
/*       Quasi-Newton Matrices and their use in Limited Memory Methods'', 
*/
/*       Mathematical Programming 63 (1994), no. 4, pp. 129-156. */

/*       (Postscript files of these papers are available via anonymous */
/*        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) */

/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision April 1997.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    if (lcl_s_cmp(task, "START", 60L, 5L) == 0) {
	timer_(&time1);
/*        Generate the current machine precision. */
	epsmch = dpmeps_();
	fold = 0.;
	dnorm = 0.;
	cpu1 = 0.;
	gd = 0.;
	sbgnrm = 0.;
	stp = 0.;
	stpmx = 0.;
	gdold = 0.;
	dtd = 0.;
/*        Initialize counters and scalars when task='START'. */
/*           for the limited memory BFGS matrices: */
	col = 0;
	head = 1;
	theta = 1.;
	iupdat = 0;
	updatd = FALSE_;
	iback = 0;
	itail = 0;
	ifun = 0;
	iword = 0;
	nact = 0;
	ileave = 0;
	nenter = 0;
/*           for operation counts: */
	iter = 0;
	nfgv = 0;
	nint = 0;
	nintol = 0;
	nskip = 0;
	nfree = *n;
/*           for stopping tolerance: */
	tol = *factr * epsmch;
/*           for measuring running time: */
	cachyt = 0.;
	sbtime = 0.;
	lnscht = 0.;
/*           'word' records the status of subspace solutions. */
	lcl_s_copy(word, "---", 3L, 3L);
/*           'info' records the termination information. */
	info = 0;
	itfile = 0;
	if (*iprint >= 1) {
/*                                open a summary file 
'iterate.dat' */
	    itfile = 0; /* all output now done to stdout or stderr */
	}
/*        Check the input arguments for errors. */
	errclb_(n, m, factr, &l[1], &u[1], &nbd[1], task, &info, &k, 60L);
	if (lcl_s_cmp(task, "ERROR", 5L, 5L) == 0) {
	    prn3lb_(n, &x[1], f, task, iprint, &info, &itfile, &iter, &nfgv, &
		    nintol, &nskip, &nact, &sbgnrm, &c_b9, &nint, word, &
		    iback, &stp, &xstep, &k, &cachyt, &sbtime, &lnscht, 60L, 
		    3L);
	    return 0;
	}
	prn1lb_(n, m, &l[1], &u[1], &x[1], iprint, &itfile, &epsmch);
/*        Initialize iwhere & project x onto the feasible set. */
	active_(n, &l[1], &u[1], &nbd[1], &x[1], &iwhere[1], iprint, &prjctd, 
		&cnstnd, &boxed);
/*        The end of the initialization. */
    } else {
/*          restore local variables. */
	prjctd = lsave[1];
	cnstnd = lsave[2];
	boxed = lsave[3];
	updatd = lsave[4];
	nintol = isave[1];
	itfile = isave[3];
	iback = isave[4];
	nskip = isave[5];
	head = isave[6];
	col = isave[7];
	itail = isave[8];
	iter = isave[9];
	iupdat = isave[10];
	nint = isave[12];
	nfgv = isave[13];
	info = isave[14];
	ifun = isave[15];
	iword = isave[16];
	nfree = isave[17];
	nact = isave[18];
	ileave = isave[19];
	nenter = isave[20];
	theta = dsave[1];
	fold = dsave[2];
	tol = dsave[3];
	dnorm = dsave[4];
	epsmch = dsave[5];
	cpu1 = dsave[6];
	cachyt = dsave[7];
	sbtime = dsave[8];
	lnscht = dsave[9];
	time1 = dsave[10];
	gd = dsave[11];
	stpmx = dsave[12];
	sbgnrm = dsave[13];
	stp = dsave[14];
	gdold = dsave[15];
	dtd = dsave[16];
/*        After returning from the driver go to the point where 
execution */
/*        is to resume. */
	if (lcl_s_cmp(task, "FG_LN", 5L, 5L) == 0) {
	    goto L666;
	}
	if (lcl_s_cmp(task, "NEW_X", 5L, 5L) == 0) {
	    goto L777;
	}
	if (lcl_s_cmp(task, "FG_ST", 5L, 5L) == 0) {
	    goto L111;
	}
	if (lcl_s_cmp(task, "STOP", 4L, 4L) == 0) {
	    if (lcl_s_cmp(task + 6, "CPU", 3L, 3L) == 0) {
/*                                          restore the 
previous iterate. */
		dcopy_(n, &t[1], &c__1, &x[1], &c__1);
		dcopy_(n, &r[1], &c__1, &g[1], &c__1);
		*f = fold;
	    }
	    goto L999;
	}
    }
/*     Compute f0 and g0. */
    lcl_s_copy(task, "FG_START", 60L, 8L);
/*          return to the driver to calculate f and g; reenter at 111. */
    goto L1000;
L111:
    nfgv = 1;
/*     Compute the infinity norm of the (-) projected gradient. */
    projgr_(n, &l[1], &u[1], &nbd[1], &x[1], &g[1], &sbgnrm);
    if (*iprint >= 1) {
      fprintf(stdout,
	      "At iterate %5d    f= %12.5lf    |proj g|= %12.5f\n",
	      iter,*f,sbgnrm);
      fprintf(stdout,
	      " %4d %4d      -     -   -     -     -        -     %10.3lf %10.3lf\n",
	      iter,nfgv,sbgnrm,*f);
    }
    if (sbgnrm <= *pgtol) {
/*                                terminate the algorithm. */
	lcl_s_copy(task, "CONVERGENCE: NORM OF PROJECTED GRADIENT <= PGTOL", 60L, 
		48L);
	goto L999;
    }
/* ----------------- the beginning of the loop -------------------------- 
*/
L222:
    if (*iprint >= 99) {
      fprintf(stdout,"ITERATION %5d\n",iter+1);
    }
    iword = -1;

    if (! cnstnd && col > 0) {
/*                                            skip the search for 
GCP. */
	dcopy_(n, &x[1], &c__1, &z[1], &c__1);
	wrk = updatd;
	nint = 0;
	goto L333;
    }
/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */

/*     Compute the Generalized Cauchy Point (GCP). */

/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */
    timer_(&cpu1);
    cauchy_(n, &x[1], &l[1], &u[1], &nbd[1], &g[1], &indx2[1], &iwhere[1], &t[
	    1], &d[1], &z[1], m, &wy[wy_offset], &ws[ws_offset], &sy[
	    sy_offset], &wt[wt_offset], &theta, &col, &head, &wa[1], &wa[(*m 
	    << 1) + 1], &wa[(*m << 2) + 1], &wa[*m * 6 + 1], &nint, iprint, &
	    sbgnrm, &info, &epsmch);
    if (info != 0) {
/*         singular triangular system detected; refresh the lbfgs 
memory. */
	if (*iprint >= 1) {
	  fprintf(stdout," Singular triangular system detected;\n");
	  fprintf(stdout,"   refresh the lbfgs memory and restart the iteration.\n");
	}
	info = 0;
	col = 0;
	head = 1;
	theta = 1.;
	iupdat = 0;
	updatd = FALSE_;
	timer_(&cpu2);
	cachyt = cachyt + cpu2 - cpu1;
	goto L222;
    }
    timer_(&cpu2);
    cachyt = cachyt + cpu2 - cpu1;
    nintol += nint;
/*     Count the entering and leaving variables for iter > 0; */
/*     find the index set of free and active variables at the GCP. */
    freev_(n, &nfree, &index[1], &nenter, &ileave, &indx2[1], &iwhere[1], &
	    wrk, &updatd, &cnstnd, iprint, &iter);
    nact = *n - nfree;
L333:
/*     If there are no free variables or B=theta*I, then */
/*                                        skip the subspace minimization. 
*/
    if (nfree == 0 || col == 0) {
	goto L555;
    }
/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */

/*     Subspace minimization. */

/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */
    timer_(&cpu1);
/*     Form  the LEL^T factorization of the indefinite */
/*       matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ] */
/*                     [L_a -R_z           theta*S'AA'S ] */
/*       where     E = [-I  0] */
/*                     [ 0  I] */
    if (wrk) {
	formk_(n, &nfree, &index[1], &nenter, &ileave, &indx2[1], &iupdat, &
		updatd, &wn[wn_offset], &snd[snd_offset], m, &ws[ws_offset], &
		wy[wy_offset], &sy[sy_offset], &theta, &col, &head, &info);
    }
    if (info != 0) {
/*          nonpositive definiteness in Cholesky factorization; */
/*          refresh the lbfgs memory and restart the iteration. */
	if (*iprint >= 1) {
	  fprintf(stdout,"Nonpositive definiteness in Cholesky factorization in formk;\n");
	  fprintf(stdout,"   refresh the lbfgs memory and restart the iteration.\n");
	}
	info = 0;
	col = 0;
	head = 1;
	theta = 1.;
	iupdat = 0;
	updatd = FALSE_;
	timer_(&cpu2);
	sbtime = sbtime + cpu2 - cpu1;
	goto L222;
    }
/*        compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x) */
/*                                                   from 'cauchy'). */
    cmprlb_(n, m, &x[1], &g[1], &ws[ws_offset], &wy[wy_offset], &sy[sy_offset]
	    , &wt[wt_offset], &z[1], &r[1], &wa[1], &index[1], &theta, &col, &
	    head, &nfree, &cnstnd, &info);
    if (info != 0) {
	goto L444;
    }
/*       call the direct method. */
    subsm_(n, m, &nfree, &index[1], &l[1], &u[1], &nbd[1], &z[1], &r[1], &ws[
	    ws_offset], &wy[wy_offset], &theta, &col, &head, &iword, &wa[1], &
	    wn[wn_offset], iprint, &info);
L444:
    if (info != 0) {
/*          singular triangular system detected; */
/*          refresh the lbfgs memory and restart the iteration. */
	if (*iprint >= 1) {
	  fprintf(stdout,"Singular triangular system detected;\n");
	  fprintf(stdout,"   refresh the lbfgs memory and restart the iteration.\n");
	}
	info = 0;
	col = 0;
	head = 1;
	theta = 1.;
	iupdat = 0;
	updatd = FALSE_;
	timer_(&cpu2);
	sbtime = sbtime + cpu2 - cpu1;
	goto L222;
    }
    timer_(&cpu2);
    sbtime = sbtime + cpu2 - cpu1;
L555:
/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */

/*     Line search and optimality tests. */

/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */
/*     Generate the search direction d:=z-x. */
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	d[i] = z[i] - x[i];
/* L40: */
    }
    timer_(&cpu1);
L666:
    lnsrlb_(n, &l[1], &u[1], &nbd[1], &x[1], f, &fold, &gd, &gdold, &g[1], &d[
	    1], &r[1], &t[1], &z[1], &stp, &dnorm, &dtd, &xstep, &stpmx, &
	    iter, &ifun, &iback, &nfgv, &info, task, &boxed, &cnstnd, csave, &
	    isave[22], &dsave[17], 60L, 60L);
    if (info != 0 || iback >= 20) {
/*          restore the previous iterate. */
	dcopy_(n, &t[1], &c__1, &x[1], &c__1);
	dcopy_(n, &r[1], &c__1, &g[1], &c__1);
	*f = fold;
	if (col == 0) {
/*             abnormal termination. */
	    if (info == 0) {
		info = -9;
/*                restore the actual number of f and g 
evaluations etc. */
		--nfgv;
		--ifun;
		--iback;
	    }
	    lcl_s_copy(task, "ABNORMAL_TERMINATION_IN_LNSRCH", 60L, 30L);
	    ++iter;
	    goto L999;
	} else {
/*             refresh the lbfgs memory and restart the 
iteration. */
	    if (*iprint >= 1) {
	      fprintf(stdout," Bad direction in the line search;\n");
	      fprintf(stdout,"   refresh the lbfgs memory and restart the iteration.\n");
	    }
	    if (info == 0) {
		--nfgv;
	    }
	    info = 0;
	    col = 0;
	    head = 1;
	    theta = 1.;
	    iupdat = 0;
	    updatd = FALSE_;
	    lcl_s_copy(task, "RESTART_FROM_LNSRCH", 60L, 19L);
	    timer_(&cpu2);
	    lnscht = lnscht + cpu2 - cpu1;
	    goto L222;
	}
    } else if (lcl_s_cmp(task, "FG_LN", 5L, 5L) == 0) {
/*          return to the driver for calculating f and g; reenter at 
666. */
	goto L1000;
    } else {
/*          calculate and print out the quantities related to the new 
X. */
	timer_(&cpu2);
	lnscht = lnscht + cpu2 - cpu1;
	++iter;
/*        Compute the infinity norm of the projected (-)gradient. */
	projgr_(n, &l[1], &u[1], &nbd[1], &x[1], &g[1], &sbgnrm);
/*        Print iteration information. */
	prn2lb_(n, &x[1], f, &g[1], iprint, &itfile, &iter, &nfgv, &nact, &
		sbgnrm, &nint, word, &iword, &iback, &stp, &xstep, 3L);
	goto L1000;
    }
L777:
/*     Test for termination. */
    if (sbgnrm <= *pgtol) {
/*                                terminate the algorithm. */
	lcl_s_copy(task, "CONVERGENCE: NORM OF PROJECTED GRADIENT <= PGTOL", 60L, 
		48L);
	goto L999;
    }
/* Computing MAX */
    d_1 = fabs(fold), d_2 = fabs(*f), d_1 = max(d_2,d_1);
    ddum = max(1.,d_1);
    if (fold - *f <= tol * ddum) {
/*                                        terminate the algorithm. */
	lcl_s_copy(task, "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH", 60L, 
		47L);
	if (iback >= 10) {
	    info = -5;
	}
/*           i.e., to issue a warning if iback>10 in the line search. 
*/
	goto L999;
    }
/*     Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's. */
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	r[i] = g[i] - r[i];
/* L42: */
    }
    rr = ddot_(n, &r[1], &c__1, &r[1], &c__1);
    if (stp == 1.) {
	dr = gd - gdold;
	ddum = -gdold;
    } else {
	dr = (gd - gdold) * stp;
	dscal_(n, &stp, &d[1], &c__1);
	ddum = -gdold * stp;
    }
    if (dr <= epsmch * ddum) {
/*                            skip the L-BFGS update. */
	++nskip;
	updatd = FALSE_;
	if (*iprint >= 1) {
	  fprintf(stdout,"  ys=  %10.3e  -gs=  %10.3e BFGS update SKIPPED\n",
		  dr,ddum);
	}
	goto L888;
    }
/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */

/*     Update the L-BFGS matrix. */

/* 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccc */
    updatd = TRUE_;
    ++iupdat;
/*     Update matrices WS and WY and form the middle matrix in B. */
    matupd_(n, m, &ws[ws_offset], &wy[wy_offset], &sy[sy_offset], &ss[
	    ss_offset], &d[1], &r[1], &itail, &iupdat, &col, &head, &theta, &
	    rr, &dr, &stp, &dtd);
/*     Form the upper half of the pds T = theta*SS + L*D^(-1)*L'; */
/*        Store T in the upper triangular of the array wt; */
/*        Cholesky factorize T to J*J' with */
/*           J' stored in the upper triangular of wt. */
    formt_(m, &wt[wt_offset], &sy[sy_offset], &ss[ss_offset], &col, &theta, &
	    info);
    if (info != 0) {
/*          nonpositive definiteness in Cholesky factorization; */
/*          refresh the lbfgs memory and restart the iteration. */
	if (*iprint >= 1) {
	  fprintf(stdout,"Nonpositive definiteness in Cholesky factorization in format;\n");
	  fprintf(stdout,"   refresh the lbfgs memory and restart the iteration.\n");
	}
	info = 0;
	col = 0;
	head = 1;
	theta = 1.;
	iupdat = 0;
	updatd = FALSE_;
	goto L222;
    }
/*     Now the inverse of the middle matrix in B is */
/*       [  D^(1/2)      O ] [ -D^(1/2)  D^(-1/2)*L' ] */
/*       [ -L*D^(-1/2)   J ] [  0        J'          ] */
L888:
/* -------------------- the end of the loop ----------------------------- 
*/
    goto L222;
L999:
    timer_(&time2);
    time = time2 - time1;
    prn3lb_(n, &x[1], f, task, iprint, &info, &itfile, &iter, &nfgv, &nintol, 
	    &nskip, &nact, &sbgnrm, &time, &nint, word, &iback, &stp, &xstep, 
	    &k, &cachyt, &sbtime, &lnscht, 60L, 3L);
L1000:
/*     Save local variables. */
    lsave[1] = prjctd;
    lsave[2] = cnstnd;
    lsave[3] = boxed;
    lsave[4] = updatd;
    isave[1] = nintol;
    isave[3] = itfile;
    isave[4] = iback;
    isave[5] = nskip;
    isave[6] = head;
    isave[7] = col;
    isave[8] = itail;
    isave[9] = iter;
    isave[10] = iupdat;
    isave[12] = nint;
    isave[13] = nfgv;
    isave[14] = info;
    isave[15] = ifun;
    isave[16] = iword;
    isave[17] = nfree;
    isave[18] = nact;
    isave[19] = ileave;
    isave[20] = nenter;
    dsave[1] = theta;
    dsave[2] = fold;
    dsave[3] = tol;
    dsave[4] = dnorm;
    dsave[5] = epsmch;
    dsave[6] = cpu1;
    dsave[7] = cachyt;
    dsave[8] = sbtime;
    dsave[9] = lnscht;
    dsave[10] = time1;
    dsave[11] = gd;
    dsave[12] = stpmx;
    dsave[13] = sbgnrm;
    dsave[14] = stp;
    dsave[15] = gdold;
    dsave[16] = dtd;
    return 0;
} /* mainlb_ */

/* ======================= The end of mainlb ============================= */
/* Subroutine */ int active_(int *n, double *l, double *u, 
	int *nbd, double *x, int *iwhere, int *iprint, 
	logical *prjctd, logical *cnstnd, logical *boxed)
{
    /* Format strings */
    static char fmt_1001[] = "(/,\002At X0 \002,i9,\002 variables are exactl"
	    "y at the bounds\002)";

    /* System generated locals */
    int i_1;

    /* Local variables */
    int nbdd, i;

    /* Fortran I/O blocks */
    static cilist io__76 = { 0, 6, 0, 0, 0 };
    static cilist io__77 = { 0, 6, 0, 0, 0 };
    static cilist io__78 = { 0, 6, 0, fmt_1001, 0 };


    /* Parameter adjustments */
    --l;
    --u;
    --nbd;
    --x;
    --iwhere;

    /* Function Body */
/*     ************ */

/*     Subroutine active */

/*     This subroutine initializes iwhere and projects the initial x to */

/*       the feasible set if necessary. */

/*     iwhere is an int array of dimension n. */
/*       On entry iwhere is unspecified. */
/*       On exit iwhere(i)=-1  if x(i) has no bounds */
/*                         3   if l(i)=u(i) */
/*                         0   otherwise. */
/*       In cauchy, iwhere is given finer gradations. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*     Initialize nbdd, prjctd, cnstnd and boxed. */
    nbdd = 0;
    *prjctd = FALSE_;
    *cnstnd = FALSE_;
    *boxed = TRUE_;
/*     Project the initial x to the easible set if necessary. */
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	if (nbd[i] > 0) {
	    if (nbd[i] <= 2 && x[i] <= l[i]) {
		if (x[i] < l[i]) {
		    *prjctd = TRUE_;
		    x[i] = l[i];
		}
		++nbdd;
	    } else if (nbd[i] >= 2 && x[i] >= u[i]) {
		if (x[i] > u[i]) {
		    *prjctd = TRUE_;
		    x[i] = u[i];
		}
		++nbdd;
	    }
	}
/* L10: */
    }
/*     Initialize iwhere and assign values to cnstnd and boxed. */
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	if (nbd[i] != 2) {
	    *boxed = FALSE_;
	}
	if (nbd[i] == 0) {
/*                                this variable is always free */
	    iwhere[i] = -1;
/*           otherwise set x(i)=mid(x(i), u(i), l(i)). */
	} else {
	    *cnstnd = TRUE_;
	    if (nbd[i] == 2 && u[i] - l[i] <= 0.) {
/*                   this variable is always fixed */
		iwhere[i] = 3;
	    } else {
		iwhere[i] = 0;
	    }
	}
/* L20: */
    }
    if (*iprint >= 0) {
	if (*prjctd) {
	  fprintf(stdout,"The initial X is infeasible.  Restart with its projection.\n");
	}
	if (! (*cnstnd)) {
	  fprintf(stdout,"This problem is unconstrained.\n");
	}
    }
    if (*iprint > 0) {
      fprintf(stdout,"At X0 %9d variables are exactly at the bounds\n",
	      nbdd);
    }
    return 0;
} /* active_ */

/* ======================= The end of active ============================= */
/* Subroutine */ int bmv_(int *m, double *sy, double *wt, int 
	*col, double *v, double *p, int *info)
{
    /* System generated locals */
    int sy_dim1, sy_offset, wt_dim1, wt_offset, i_1, i_2;

    /* Builtin functions */
    double sqrt(double);

    /* Local variables */
    int i, k;
    extern /* Subroutine */ int dtrsl_(double *, int *, int *, 
	    double *, int *, int *);
    int i2;
    double sum;

    /* Parameter adjustments */
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;
    wt_dim1 = *m;
    wt_offset = wt_dim1 + 1;
    wt -= wt_offset;
    --v;
    --p;

    /* Function Body */
/*     ************ */

/*     Subroutine bmv */

/*     This subroutine computes the product of the 2m x 2m middle matrix 
*/
/*       in the compact L-BFGS formula of B and a 2m vector v; */
/*       it returns the product in p. */

/*     m is an int variable. */
/*       On entry m is the maximum number of variable metric corrections 
*/
/*         used to define the limited memory matrix. */
/*       On exit m is unchanged. */

/*     sy is a double precision array of dimension m x m. */
/*       On entry sy specifies the matrix S'Y. */
/*       On exit sy is unchanged. */

/*     wt is a double precision array of dimension m x m. */
/*       On entry wt specifies the upper triangular matrix J' which is */
/*         the Cholesky factor of (thetaS'S+LD^(-1)L'). */
/*       On exit wt is unchanged. */

/*     col is an int variable. */
/*       On entry col specifies the number of s-vectors (or y-vectors) */
/*         stored in the compact L-BFGS formula. */
/*       On exit col is unchanged. */

/*     v is a double precision array of dimension 2col. */
/*       On entry v specifies vector v. */
/*       On exit v is unchanged. */

/*     p is a double precision array of dimension 2col. */
/*       On entry p is unspecified. */
/*       On exit p is the product Mv. */

/*     info is an int variable. */
/*       On entry info is unspecified. */
/*       On exit info = 0       for normal return, */
/*                    = nonzero for abnormal return when the system */
/*                                to be solved by dtrsl is singular. */

/*     Subprograms called: */

/*       Linpack ... dtrsl. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    if (*col == 0) {
	return 0;
    }
/*     PART I: solve [  D^(1/2)      O ] [ p1 ] = [ v1 ] */
/*                   [ -L*D^(-1/2)   J ] [ p2 ]   [ v2 ]. */
/*       solve Jp2=v2+LD^(-1)v1. */
    p[*col + 1] = v[*col + 1];
    i_1 = *col;
    for (i = 2; i <= i_1; ++i) {
	i2 = *col + i;
	sum = 0.;
	i_2 = i - 1;
	for (k = 1; k <= i_2; ++k) {
	    sum += sy[i + k * sy_dim1] * v[k] / sy[k + k * sy_dim1];
/* L10: */
	}
	p[i2] = v[i2] + sum;
/* L20: */
    }
/*     Solve the triangular system */
    dtrsl_(&wt[wt_offset], m, col, &p[*col + 1], &c__11, info);
    if (*info != 0) {
	return 0;
    }
/*       solve D^(1/2)p1=v1. */
    i_1 = *col;
    for (i = 1; i <= i_1; ++i) {
	p[i] = v[i] / sqrt(sy[i + i * sy_dim1]);
/* L30: */
    }
/*     PART II: solve [ -D^(1/2)   D^(-1/2)*L'  ] [ p1 ] = [ p1 ] */
/*                    [  0         J'           ] [ p2 ]   [ p2 ]. */
/*       solve J^Tp2=p2. */
    dtrsl_(&wt[wt_offset], m, col, &p[*col + 1], &c__1, info);
    if (*info != 0) {
	return 0;
    }
/*       compute p1=-D^(-1/2)(p1-D^(-1/2)L'p2) */
/*                 =-D^(-1/2)p1+D^(-1)L'p2. */
    i_1 = *col;
    for (i = 1; i <= i_1; ++i) {
	p[i] = -p[i] / sqrt(sy[i + i * sy_dim1]);
/* L40: */
    }
    i_1 = *col;
    for (i = 1; i <= i_1; ++i) {
	sum = 0.;
	i_2 = *col;
	for (k = i + 1; k <= i_2; ++k) {
	    sum += sy[k + i * sy_dim1] * p[*col + k] / sy[i + i * sy_dim1];
/* L50: */
	}
	p[i] += sum;
/* L60: */
    }
    return 0;
} /* bmv_ */

/* ======================== The end of bmv =============================== */
/* Subroutine */ int cauchy_(int *n, double *x, double *l, 
	double *u, int *nbd, double *g, int *iorder, int *
	iwhere, double *t, double *d, double *xcp, int *m, 
	double *wy, double *ws, double *sy, double *wt, 
	double *theta, int *col, int *head, double *p, 
	double *c, double *wbp, double *v, int *nint, int 
	*iprint, double *sbgnrm, int *info, double *epsmch)
{

    /* System generated locals */
    int wy_dim1, wy_offset, ws_dim1, ws_offset, sy_dim1, sy_offset, 
	    wt_dim1, wt_offset, i_1, i_2;
    double d_1;

    /* Local variables */
    double dibp;
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    int iter;
    double zibp, tsum, dibp2;
    int i, j;
    logical bnded;
    extern /* Subroutine */ int dscal_(int *, double *, double *, 
	    int *);
    double neggi;
    int nfree;
    double bkmin;
    int nleft;
    extern /* Subroutine */ int dcopy_(int *, double *, int *, 
	    double *, int *), daxpy_(int *, double *, 
	    double *, int *, double *, int *);
    double f1, f2, f2_org__, dt, tj, tl;
    int nbreak, ibkmin;
    double tu;
    extern /* Subroutine */ int hpsolb_(int *, double *, int *, 
	    int *);
    int pointr;
    double tj0;
    logical xlower, xupper;
    int ibp;
    double dtm;
    extern /* Subroutine */ int bmv_(int *, double *, double *, 
	    int *, double *, double *, int *);
    double wmc, wmp, wmw;
    int col2;


    /* Parameter adjustments */
    --x;
    --l;
    --u;
    --nbd;
    --g;
    --iorder;
    --iwhere;
    --t;
    --d;
    --xcp;
    wy_dim1 = *n;
    wy_offset = wy_dim1 + 1;
    wy -= wy_offset;
    ws_dim1 = *n;
    ws_offset = ws_dim1 + 1;
    ws -= ws_offset;
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;
    wt_dim1 = *m;
    wt_offset = wt_dim1 + 1;
    wt -= wt_offset;
    --p;
    --c;
    --wbp;
    --v;

    /* Function Body */
/*     ************ */

/*     Subroutine cauchy */

/*     For given x, l, u, g (with sbgnrm > 0), and a limited memory */
/*       On entry head is the location of the first s-vector */
/*         (or y-vector) in S (or Y). */
/*       On exit col is unchanged. */

/*     p is a double precision working array of dimension 2m. */
/*       p will be used to store the vector p = W^(T)d. */

/*     c is a double precision working array of dimension 2m. */
/*       c will be used to store the vector c = W^(T)(xcp-x). */

/*     wbp is a double precision working array of dimension 2m. */
/*       wbp will be used to store the row of W corresponding */
/*         to a breakpoint. */

/*     v is a double precision working array of dimension 2m. */

/*     nint is an int variable. */
/*       On exit nint records the number of quadratic segments explored */

/*         in searching for the GCP. */

/*     iprint is an INT variable that must be set by the user. */
/*       It controls the frequency and type of output generated: */
/*        iprint<0    no output is generated; */
/*        iprint=0    print only one line at the last iteration; */
/*        0<iprint<99 print also f and |proj g| every iprint iterations; 
*/
/*        iprint=99   print details of every iteration except n-vectors; 
*/
/*        iprint=100  print also the changes of active set and final x; */

/*        iprint>100  print details of every iteration including x and g; 
*/
/*       When iprint > 0, the file iterate.dat will be created to */
/*                        summarize the iteration. */

/*     sbgnrm is a double precision variable. */
/*       On entry sbgnrm is the norm of the projected gradient at x. */
/*       On exit sbgnrm is unchanged. */

/*     info is an int variable. */
/*       On entry info is 0. */
/*       On exit info = 0       for normal return, */
/*                    = nonzero for abnormal return when the the system */

/*                              used in routine bmv is singular. */

/*     Subprograms called: */

/*       L-BFGS-B Library ... hpsolb, bmv. */

/*       Linpack ... dscal dcopy, daxpy. */


/*     References: */

/*       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited */
/*       memory algorithm for bound constrained optimization'', */
/*       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. */


/*       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN */
/*       Subroutines for Large Scale Bound Constrained Optimization'' */
/*       Tech. Report, NAM-11, EECS Department, Northwestern University, 
*/
/*       1994. */

/*       (Postscript files of these papers are available via anonymous */
/*        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) */

/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision April 1997.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*     Check the status of the variables, reset iwhere(i) if necessary; */

/*       compute the Cauchy direction d and the breakpoints t; initialize 
*/
/*       the derivative f1 and the vector p = W'd (for theta = 1). */
    if (*sbgnrm <= 0.) {
	if (*iprint >= 0) {
	  fprintf(stdout,"Subgnorm = 0.   GCP = X.\n");
	}
	dcopy_(n, &x[1], &c__1, &xcp[1], &c__1);
	return 0;
    }
    bnded = TRUE_;
    nfree = *n + 1;
    nbreak = 0;
    ibkmin = 0;
    bkmin = 0.;
    col2 = *col << 1;
    f1 = 0.;
    if (*iprint >= 99) {
      fprintf(stdout,"---------------- CAUCHY entered-------------------\n");
    }
/*     We set p to zero and build it up as we determine d. */
    i_1 = col2;
    for (i = 1; i <= i_1; ++i) {
	p[i] = 0.;
/* L20: */
    }
/*     In the following loop we determine for each variable its bound */
/*        status and its breakpoint, and update p accordingly. */
/*        Smallest breakpoint is identified. */
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	neggi = -g[i];
	if (iwhere[i] != 3 && iwhere[i] != -1) {
/*             if x(i) is not a constant and has bounds, */
/*             compute the difference between x(i) and its 
bounds. */
	    if (nbd[i] <= 2) {
		tl = x[i] - l[i];
	    }
	    if (nbd[i] >= 2) {
		tu = u[i] - x[i];
	    }
/*           If a variable is close enough to a bound */
/*             we treat it as at bound. */
	    xlower = nbd[i] <= 2 && tl <= 0.;
	    xupper = nbd[i] >= 2 && tu <= 0.;
/*              reset iwhere(i). */
	    iwhere[i] = 0;
	    if (xlower) {
		if (neggi <= 0.) {
		    iwhere[i] = 1;
		}
	    } else if (xupper) {
		if (neggi >= 0.) {
		    iwhere[i] = 2;
		}
	    } else {
		if (fabs(neggi) <= 0.) {
		    iwhere[i] = -3;
		}
	    }
	}
	pointr = *head;
	if (iwhere[i] != 0 && iwhere[i] != -1) {
	    d[i] = 0.;
	} else {
	    d[i] = neggi;
	    f1 -= neggi * neggi;
/*             calculate p := p - W'e_i* (g_i). */
	    i_2 = *col;
	    for (j = 1; j <= i_2; ++j) {
		p[j] += wy[i + pointr * wy_dim1] * neggi;
		p[*col + j] += ws[i + pointr * ws_dim1] * neggi;
		pointr = pointr % *m + 1;
/* L40: */
	    }
	    if (nbd[i] <= 2 && nbd[i] != 0 && neggi < 0.) {
/*                                 x(i) + d(i) is bounded; 
compute t(i). */
		++nbreak;
		iorder[nbreak] = i;
		t[nbreak] = tl / (-neggi);
		if (nbreak == 1 || t[nbreak] < bkmin) {
		    bkmin = t[nbreak];
		    ibkmin = nbreak;
		}
	    } else if (nbd[i] >= 2 && neggi > 0.) {
/*                                 x(i) + d(i) is bounded; 
compute t(i). */
		++nbreak;
		iorder[nbreak] = i;
		t[nbreak] = tu / neggi;
		if (nbreak == 1 || t[nbreak] < bkmin) {
		    bkmin = t[nbreak];
		    ibkmin = nbreak;
		}
	    } else {
/*                x(i) + d(i) is not bounded. */
		--nfree;
		iorder[nfree] = i;
		if (fabs(neggi) > 0.) {
		    bnded = FALSE_;
		}
	    }
	}
/* L50: */
    }
/*     The indices of the nonzero components of d are now stored */
/*       in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n). 
*/
/*       The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin. */
    if (*theta != 1.) {
/*                   complete the initialization of p for theta not= 
one. */
	dscal_(col, theta, &p[*col + 1], &c__1);
    }
/*     Initialize GCP xcp = x. */
    dcopy_(n, &x[1], &c__1, &xcp[1], &c__1);
    if (nbreak == 0 && nfree == *n + 1) {
/*                  is a zero vector, return with the initial xcp as 
GCP. */
	if (*iprint > 100) {
	  i_1 = *n;
	  fprintf(stdout,"Cauchy X =  ");
	  for (i = 1; i <= i_1; ++i) {
	    fprintf(stdout,"%11.4lf ",xcp[i]);
	  }
	  fprintf(stdout,"\n");
	}
	return 0;
    }
/*     Initialize c = W'(xcp - x) = 0. */
    i_1 = col2;
    for (j = 1; j <= i_1; ++j) {
	c[j] = 0.;
/* L60: */
    }
/*     Initialize derivative f2. */
    f2 = -(*theta) * f1;
    f2_org__ = f2;
    if (*col > 0) {
	bmv_(m, &sy[sy_offset], &wt[wt_offset], col, &p[1], &v[1], info);
	if (*info != 0) {
	    return 0;
	}
	f2 -= ddot_(&col2, &v[1], &c__1, &p[1], &c__1);
    }
    dtm = -f1 / f2;
    tsum = 0.;
    *nint = 1;
    if (*iprint >= 99) {
      fprintf(stdout,"There are %d breakpoints\n", nbreak);
    }
/*     If there are no breakpoints, locate the GCP and return. */
    if (nbreak == 0) {
	goto L888;
    }
    nleft = nbreak;
    iter = 1;
    tj = 0.;
/* ------------------- the beginning of the loop 
------------------------- */
L777:
/*     Find the next smallest breakpoint; */
/*       compute dt = t(nleft) - t(nleft + 1). */
    tj0 = tj;
    if (iter == 1) {
/*         Since we already have the smallest breakpoint we need not 
do */
/*         heapsort yet. Often only one breakpoint is used and the */
/*         cost of heapsort is avoided. */
	tj = bkmin;
	ibp = iorder[ibkmin];
    } else {
	if (iter == 2) {
/*             Replace the already used smallest breakpoint with 
the */
/*             breakpoint numbered nbreak > nlast, before 
heapsort call. */
	    if (ibkmin != nbreak) {
		t[ibkmin] = t[nbreak];
		iorder[ibkmin] = iorder[nbreak];
	    }
/*        Update heap structure of breakpoints */
/*           (if iter=2, initialize heap). */
	}
	i_1 = iter - 2;
	hpsolb_(&nleft, &t[1], &iorder[1], &i_1);
	tj = t[nleft];
	ibp = iorder[nleft];
    }
    dt = tj - tj0;
    if (dt != 0. && *iprint >= 100) {
      fprintf(stdout,
	      "Piece    %3d --f1, f2 at start point  %11.4lf %11.4lf\n",
	      *nint, f1, f2);
      fprintf(stdout,"Distance to the next break point =  %11.4lf\n",
	      dt);
      fprintf(stdout,"Distance to the stationary point =  %11.4lf\n",
	      dtm);
    }
/*     If a minimizer is within this interval, */
/*       locate the GCP and return. */
    if (dtm < dt) {
	goto L888;
    }
/*     Otherwise fix one variable and */
/*       reset the corresponding component of d to zero. */
    tsum += dt;
    --nleft;
    ++iter;
    dibp = d[ibp];
    d[ibp] = 0.;
    if (dibp > 0.) {
	zibp = u[ibp] - x[ibp];
	xcp[ibp] = u[ibp];
	iwhere[ibp] = 2;
    } else {
	zibp = l[ibp] - x[ibp];
	xcp[ibp] = l[ibp];
	iwhere[ibp] = 1;
    }
    if (*iprint >= 100) {
      fprintf(stdout,"Variable  %d  is fixed.\n",ibp);
    }
    if (nleft == 0 && nbreak == *n) {
/*                                             all n variables are 
fixed, */
/*                                                return with xcp as 
GCP. */
	dtm = dt;
	goto L999;
    }
/*     Update the derivative information. */
    ++(*nint);
/* Computing 2nd power */
    d_1 = dibp;
    dibp2 = d_1 * d_1;
/*     Update f1 and f2. */
/*        temporarily set f1 and f2 for col=0. */
    f1 = f1 + dt * f2 + dibp2 - *theta * dibp * zibp;
    f2 -= *theta * dibp2;
    if (*col > 0) {
/*                          update c = c + dt*p. */
	daxpy_(&col2, &dt, &p[1], &c__1, &c[1], &c__1);
/*           choose wbp, */
/*           the row of W corresponding to the breakpoint 
encountered. */
	pointr = *head;
	i_1 = *col;
	for (j = 1; j <= i_1; ++j) {
	    wbp[j] = wy[ibp + pointr * wy_dim1];
	    wbp[*col + j] = *theta * ws[ibp + pointr * ws_dim1];
	    pointr = pointr % *m + 1;
/* L70: */
	}
/*           compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)'. */
	bmv_(m, &sy[sy_offset], &wt[wt_offset], col, &wbp[1], &v[1], info);
	if (*info != 0) {
	    return 0;
	}
	wmc = ddot_(&col2, &c[1], &c__1, &v[1], &c__1);
	wmp = ddot_(&col2, &p[1], &c__1, &v[1], &c__1);
	wmw = ddot_(&col2, &wbp[1], &c__1, &v[1], &c__1);
/*           update p = p - dibp*wbp. */
	d_1 = -dibp;
	daxpy_(&col2, &d_1, &wbp[1], &c__1, &p[1], &c__1);
/*           complete updating f1 and f2 while col > 0. */
	f1 += dibp * wmc;
	f2 = f2 + dibp * 2. * wmp - dibp2 * wmw;
    }
/* Computing MAX */
    d_1 = *epsmch * f2_org__;
    f2 = max(f2,d_1);
    if (nleft > 0) {
	dtm = -f1 / f2;
	goto L777;
/*                 to repeat the loop for unsearched intervals. */
    } else if (bnded) {
	f1 = 0.;
	f2 = 0.;
	dtm = 0.;
    } else {
	dtm = -f1 / f2;
    }
/* ------------------- the end of the loop 
------------------------------- */
L888:
    if (*iprint >= 99) {
      fprintf(stdout,"\nGCP found in this segment\n");
      fprintf(stdout,"Piece    %3d --f1, f2 at start point  %11.4lf %11.4lf\n",
	      *nint,f1,f2);
      fprintf(stdout,"Distance to the stationary point =  %11.4lf\n",dtm);
    }
    if (dtm <= 0.) {
	dtm = 0.;
    }
    tsum += dtm;
/*     Move free variables (i.e., the ones w/o breakpoints) and */
/*       the variables whose breakpoints haven't been reached. */
    daxpy_(n, &tsum, &d[1], &c__1, &xcp[1], &c__1);
L999:
/*     Update c = c + dtm*p = W'(x^c - x) */
/*       which will be used in computing r = Z'(B(x^c - x) + g). */
    if (*col > 0) {
	daxpy_(&col2, &dtm, &p[1], &c__1, &c[1], &c__1);
    }
    if (*iprint > 100) {
      i_1 = *n;
      fprintf(stdout,"Cauchy X =  ");
      for (i = 1; i <= i_1; ++i) {
	fprintf(stdout,"%11.4lf ",xcp[i]);
      }
      fprintf(stdout,"\n");
    }
    if (*iprint >= 99) {
      fprintf(stdout,"---------------- exit CAUCHY----------------------\n");
    }
    return 0;
} /* cauchy_ */

/* ====================== The end of cauchy ============================== */
/* Subroutine */ int cmprlb_(int *n, int *m, double *x, 
	double *g, double *ws, double *wy, double *sy, 
	double *wt, double *z, double *r, double *wa, int 
	*index, double *theta, int *col, int *head, int *
	nfree, logical *cnstnd, int *info)
{
    /* System generated locals */
    int ws_dim1, ws_offset, wy_dim1, wy_offset, sy_dim1, sy_offset, 
	    wt_dim1, wt_offset, i_1, i_2;

    /* Local variables */
    int i, j, k;
    double a1, a2;
    int pointr;
    extern /* Subroutine */ int bmv_(int *, double *, double *, 
	    int *, double *, double *, int *);

    /* Parameter adjustments */
    --x;
    --g;
    ws_dim1 = *n;
    ws_offset = ws_dim1 + 1;
    ws -= ws_offset;
    wy_dim1 = *n;
    wy_offset = wy_dim1 + 1;
    wy -= wy_offset;
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;
    wt_dim1 = *m;
    wt_offset = wt_dim1 + 1;
    wt -= wt_offset;
    --z;
    --r;
    --wa;
    --index;

    /* Function Body */
/*     ************ */

/*     Subroutine cmprlb */

/*       This subroutine computes r=-Z'B(xcp-xk)-Z'g by using */
/*         wa(2m+1)=W'(xcp-x) from subroutine cauchy. */

/*     Subprograms called: */

/*       L-BFGS-B Library ... bmv. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    if (! (*cnstnd) && *col > 0) {
	i_1 = *n;
	for (i = 1; i <= i_1; ++i) {
	    r[i] = -g[i];
/* L26: */
	}
    } else {
	i_1 = *nfree;
	for (i = 1; i <= i_1; ++i) {
	    k = index[i];
	    r[i] = -(*theta) * (z[k] - x[k]) - g[k];
/* L30: */
	}
	bmv_(m, &sy[sy_offset], &wt[wt_offset], col, &wa[(*m << 1) + 1], &wa[
		1], info);
	if (*info != 0) {
	    *info = -8;
	    return 0;
	}
	pointr = *head;
	i_1 = *col;
	for (j = 1; j <= i_1; ++j) {
	    a1 = wa[j];
	    a2 = *theta * wa[*col + j];
	    i_2 = *nfree;
	    for (i = 1; i <= i_2; ++i) {
		k = index[i];
		r[i] = r[i] + wy[k + pointr * wy_dim1] * a1 + ws[k + pointr * 
			ws_dim1] * a2;
/* L32: */
	    }
	    pointr = pointr % *m + 1;
/* L34: */
	}
    }
    return 0;
} /* cmprlb_ */

/* ======================= The end of cmprlb ============================= */
/* Subroutine */ int errclb_(int *n, int *m, double *factr, 
	double *l, double *u, int *nbd, char *task, int *info,
	 int *k, ftnlen task_len)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int i;

    /* Parameter adjustments */
    --l;
    --u;
    --nbd;

    /* Function Body */
/*     ************ */

/*     Subroutine errclb */

/*     This subroutine checks the validity of the input data. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision April 1997.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*     Check the input arguments for errors. */
    if (*n <= 0) {
	lcl_s_copy(task, "ERROR: N .LE. 0", 60L, 15L);
    }
    if (*m <= 0) {
	lcl_s_copy(task, "ERROR: M .LE. 0", 60L, 15L);
    }
    if (*factr < 0.) {
	lcl_s_copy(task, "ERROR: FACTR .LT. 0", 60L, 19L);
    }
/*     Check the validity of the arrays nbd(i), u(i), and l(i). */
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	if (nbd[i] < 0 || nbd[i] > 3) {
/*                                                   return */
	    lcl_s_copy(task, "ERROR: INVALID NBD", 60L, 18L);
	    *info = -6;
	    *k = i;
	}
	if (nbd[i] == 2) {
	    if (l[i] > u[i]) {
/*                                    return */
		lcl_s_copy(task, "ERROR: NO FEASIBLE SOLUTION", 60L, 27L);
		*info = -7;
		*k = i;
	    }
	}
/* L10: */
    }
    return 0;
} /* errclb_ */

/* ======================= The end of errclb ============================= */
/* Subroutine */ int formk_(int *n, int *nsub, int *ind, int *
	nenter, int *ileave, int *indx2, int *iupdat, logical *
	updatd, double *wn, double *wn1, int *m, double *ws, 
	double *wy, double *sy, double *theta, int *col, 
	int *head, int *info)
{
    /* System generated locals */
    int wn_dim1, wn_offset, wn1_dim1, wn1_offset, ws_dim1, ws_offset, 
	    wy_dim1, wy_offset, sy_dim1, sy_offset, i_1, i_2, i_3;

    /* Local variables */
    int dend, pend;
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    int upcl;
    double temp1, temp2, temp3, temp4;
    int i, k;
    extern /* Subroutine */ int dpofa_(double *, int *, int *, 
	    int *), dcopy_(int *, double *, int *, double 
	    *, int *), dtrsl_(double *, int *, int *, 
	    double *, int *, int *);
    int ipntr, jpntr, k1, m2, dbegin, is, js, iy, jy, pbegin, is1, js1, 
	    col2;

    /* Parameter adjustments */
    --ind;
    --indx2;
    wn_dim1 = *m << 1;
    wn_offset = wn_dim1 + 1;
    wn -= wn_offset;
    wn1_dim1 = *m << 1;
    wn1_offset = wn1_dim1 + 1;
    wn1 -= wn1_offset;
    ws_dim1 = *n;
    ws_offset = ws_dim1 + 1;
    ws -= ws_offset;
    wy_dim1 = *n;
    wy_offset = wy_dim1 + 1;
    wy -= wy_offset;
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;

    /* Function Body */
/*     ************ */

/*     Subroutine formk */

/*     This subroutine forms  the LEL^T factorization of the indefinite */

/*       [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a */
/*       limited memory FORTRAN code for solving bound constrained */
/*       optimization problems'', Tech. Report, NAM-11, EECS Department, 
*/
/*       Northwestern University, 1994. */

/*       (Postscript files of these papers are available via anonymous */
/*        ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.) */

/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision April 1997.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*     Form the lower triangular part of */
/*               WN1 = [Y' ZZ'Y   L_a'+R_z'] */
/*                     [L_a+R_z   S'AA'S   ] */
/*        where L_a is the strictly lower triangular part of S'AA'Y */
/*              R_z is the upper triangular part of S'ZZ'Y. */
    if (*updatd) {
	if (*iupdat > *m) {
/*                                 shift old part of WN1. */
	    i_1 = *m - 1;
	    for (jy = 1; jy <= i_1; ++jy) {
		js = *m + jy;
		i_2 = *m - jy;
		dcopy_(&i_2, &wn1[jy + 1 + (jy + 1) * wn1_dim1], &c__1, &wn1[
			jy + jy * wn1_dim1], &c__1);
		i_2 = *m - jy;
		dcopy_(&i_2, &wn1[js + 1 + (js + 1) * wn1_dim1], &c__1, &wn1[
			js + js * wn1_dim1], &c__1);
		i_2 = *m - 1;
		dcopy_(&i_2, &wn1[*m + 2 + (jy + 1) * wn1_dim1], &c__1, &wn1[*
			m + 1 + jy * wn1_dim1], &c__1);
/* L10: */
	    }
	}
/*          put new rows in blocks (1,1), (2,1) and (2,2). */
	pbegin = 1;
	pend = *nsub;
	dbegin = *nsub + 1;
	dend = *n;
	iy = *col;
	is = *m + *col;
	ipntr = *head + *col - 1;
	if (ipntr > *m) {
	    ipntr -= *m;
	}
	jpntr = *head;
	i_1 = *col;
	for (jy = 1; jy <= i_1; ++jy) {
	    js = *m + jy;
	    temp1 = 0.;
	    temp2 = 0.;
	    temp3 = 0.;
/*             compute element jy of row 'col' of Y'ZZ'Y */
	    i_2 = pend;
	    for (k = pbegin; k <= i_2; ++k) {
		k1 = ind[k];
		temp1 += wy[k1 + ipntr * wy_dim1] * wy[k1 + jpntr * wy_dim1];
/* L15: */
	    }
/*             compute elements jy of row 'col' of L_a and S'AA'S 
*/
	    i_2 = dend;
	    for (k = dbegin; k <= i_2; ++k) {
		k1 = ind[k];
		temp2 += ws[k1 + ipntr * ws_dim1] * ws[k1 + jpntr * ws_dim1];
		temp3 += ws[k1 + ipntr * ws_dim1] * wy[k1 + jpntr * wy_dim1];
/* L16: */
	    }
	    wn1[iy + jy * wn1_dim1] = temp1;
	    wn1[is + js * wn1_dim1] = temp2;
	    wn1[is + jy * wn1_dim1] = temp3;
	    jpntr = jpntr % *m + 1;
/* L20: */
	}
/*          put new column in block (2,1). */
	jy = *col;
	jpntr = *head + *col - 1;
	if (jpntr > *m) {
	    jpntr -= *m;
	}
	ipntr = *head;
	i_1 = *col;
	for (i = 1; i <= i_1; ++i) {
	    is = *m + i;
	    temp3 = 0.;
/*             compute element i of column 'col' of R_z */
	    i_2 = pend;
	    for (k = pbegin; k <= i_2; ++k) {
		k1 = ind[k];
		temp3 += ws[k1 + ipntr * ws_dim1] * wy[k1 + jpntr * wy_dim1];
/* L25: */
	    }
	    ipntr = ipntr % *m + 1;
	    wn1[is + jy * wn1_dim1] = temp3;
/* L30: */
	}
	upcl = *col - 1;
    } else {
	upcl = *col;
    }
/*       modify the old parts in blocks (1,1) and (2,2) due to changes */
/*       in the set of free variables. */
    ipntr = *head;
    i_1 = upcl;
    for (iy = 1; iy <= i_1; ++iy) {
	is = *m + iy;
	jpntr = *head;
	i_2 = iy;
	for (jy = 1; jy <= i_2; ++jy) {
	    js = *m + jy;
	    temp1 = 0.;
	    temp2 = 0.;
	    temp3 = 0.;
	    temp4 = 0.;
	    i_3 = *nenter;
	    for (k = 1; k <= i_3; ++k) {
		k1 = indx2[k];
		temp1 += wy[k1 + ipntr * wy_dim1] * wy[k1 + jpntr * wy_dim1];
		temp2 += ws[k1 + ipntr * ws_dim1] * ws[k1 + jpntr * ws_dim1];
/* L35: */
	    }
	    i_3 = *n;
	    for (k = *ileave; k <= i_3; ++k) {
		k1 = indx2[k];
		temp3 += wy[k1 + ipntr * wy_dim1] * wy[k1 + jpntr * wy_dim1];
		temp4 += ws[k1 + ipntr * ws_dim1] * ws[k1 + jpntr * ws_dim1];
/* L36: */
	    }
	    wn1[iy + jy * wn1_dim1] = wn1[iy + jy * wn1_dim1] + temp1 - temp3;

	    wn1[is + js * wn1_dim1] = wn1[is + js * wn1_dim1] - temp2 + temp4;

	    jpntr = jpntr % *m + 1;
/* L40: */
	}
	ipntr = ipntr % *m + 1;
/* L45: */
    }
/*       modify the old parts in block (2,1). */
    ipntr = *head;
    i_1 = *m + upcl;
    for (is = *m + 1; is <= i_1; ++is) {
	jpntr = *head;
	i_2 = upcl;
	for (jy = 1; jy <= i_2; ++jy) {
	    temp1 = 0.;
	    temp3 = 0.;
	    i_3 = *nenter;
	    for (k = 1; k <= i_3; ++k) {
		k1 = indx2[k];
		temp1 += ws[k1 + ipntr * ws_dim1] * wy[k1 + jpntr * wy_dim1];
/* L50: */
	    }
	    i_3 = *n;
	    for (k = *ileave; k <= i_3; ++k) {
		k1 = indx2[k];
		temp3 += ws[k1 + ipntr * ws_dim1] * wy[k1 + jpntr * wy_dim1];
/* L51: */
	    }
	    if (is <= jy + *m) {
		wn1[is + jy * wn1_dim1] = wn1[is + jy * wn1_dim1] + temp1 - 
			temp3;
	    } else {
		wn1[is + jy * wn1_dim1] = wn1[is + jy * wn1_dim1] - temp1 + 
			temp3;
	    }
	    jpntr = jpntr % *m + 1;
/* L55: */
	}
	ipntr = ipntr % *m + 1;
/* L60: */
    }
/*     Form the upper triangle of WN = [D+Y' ZZ'Y/theta   -L_a'+R_z' ] */
/*                                     [-L_a +R_z        S'AA'S*theta] */
    m2 = *m << 1;
    i_1 = *col;
    for (iy = 1; iy <= i_1; ++iy) {
	is = *col + iy;
	is1 = *m + iy;
	i_2 = iy;
	for (jy = 1; jy <= i_2; ++jy) {
	    js = *col + jy;
	    js1 = *m + jy;
	    wn[jy + iy * wn_dim1] = wn1[iy + jy * wn1_dim1] / *theta;
	    wn[js + is * wn_dim1] = wn1[is1 + js1 * wn1_dim1] * *theta;
/* L65: */
	}
	i_2 = iy - 1;
	for (jy = 1; jy <= i_2; ++jy) {
	    wn[jy + is * wn_dim1] = -wn1[is1 + jy * wn1_dim1];
/* L66: */
	}
	i_2 = *col;
	for (jy = iy; jy <= i_2; ++jy) {
	    wn[jy + is * wn_dim1] = wn1[is1 + jy * wn1_dim1];
/* L67: */
	}
	wn[iy + iy * wn_dim1] += sy[iy + iy * sy_dim1];
/* L70: */
    }
/*     Form the upper triangle of */
/*          WN= [  LL'            L^-1(-L_a'+R_z')] */
/*              [(-L_a +R_z)L'^-1   S'AA'S*theta  ] */
/*        first Cholesky factor (1,1) block of wn to get LL' */
/*                          with L' stored in the upper triangle of wn. */

    dpofa_(&wn[wn_offset], &m2, col, info);
    if (*info != 0) {
	*info = -1;
	return 0;
    }
/*        then form L^-1(-L_a'+R_z') in the (1,2) block. */
    col2 = *col << 1;
    i_1 = col2;
    for (js = *col + 1; js <= i_1; ++js) {
	dtrsl_(&wn[wn_offset], &m2, col, &wn[js * wn_dim1 + 1], &c__11, info);

/* L71: */
    }
/*     Form S'AA'S*theta + (L^-1(-L_a'+R_z'))'L^-1(-L_a'+R_z') in the */
/*        upper triangle of (2,2) block of wn. */
    i_1 = col2;
    for (is = *col + 1; is <= i_1; ++is) {
	i_2 = col2;
	for (js = is; js <= i_2; ++js) {
	    wn[is + js * wn_dim1] += ddot_(col, &wn[is * wn_dim1 + 1], &c__1, 
		    &wn[js * wn_dim1 + 1], &c__1);
/* L74: */
	}
/* L72: */
    }
/*     Cholesky factorization of (2,2) block of wn. */
    dpofa_(&wn[*col + 1 + (*col + 1) * wn_dim1], &m2, col, info);
    if (*info != 0) {
	*info = -2;
	return 0;
    }
    return 0;
} /* formk_ */

/* ======================= The end of formk ============================== */
/* Subroutine */ int formt_(int *m, double *wt, double *sy, 
	double *ss, int *col, double *theta, int *info)
{
    /* System generated locals */
    int wt_dim1, wt_offset, sy_dim1, sy_offset, ss_dim1, ss_offset, i_1, 
	    i_2, i_3;

    /* Local variables */
    double ddum;
    int i, j, k;
    extern /* Subroutine */ int dpofa_(double *, int *, int *, 
	    int *);
    int k1;

    /* Parameter adjustments */
    wt_dim1 = *m;
    wt_offset = wt_dim1 + 1;
    wt -= wt_offset;
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;
    ss_dim1 = *m;
    ss_offset = ss_dim1 + 1;
    ss -= ss_offset;

    /* Function Body */
/*     ************ */

/*     Subroutine formt */

/*       This subroutine forms the upper half of the pos. def. and symm. 
*/
/*         T = theta*SS + L*D^(-1)*L', stores T in the upper triangle */
/*         of the array wt, and performs the Cholesky factorization of T 
*/
/*         to produce J*J', with J' stored in the upper triangle of wt. */


/*     Subprograms called: */

/*       Linpack ... dpofa. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*     Form the upper half of  T = theta*SS + L*D^(-1)*L', */
/*        store T in the upper triangle of the array wt. */
    i_1 = *col;
    for (j = 1; j <= i_1; ++j) {
	wt[j * wt_dim1 + 1] = *theta * ss[j * ss_dim1 + 1];
/* L52: */
    }
    i_1 = *col;
    for (i = 2; i <= i_1; ++i) {
	i_2 = *col;
	for (j = i; j <= i_2; ++j) {
	    k1 = min(i,j) - 1;
	    ddum = 0.;
	    i_3 = k1;
	    for (k = 1; k <= i_3; ++k) {
		ddum += sy[i + k * sy_dim1] * sy[j + k * sy_dim1] / sy[k + k *
			 sy_dim1];
/* L53: */
	    }
	    wt[i + j * wt_dim1] = ddum + *theta * ss[i + j * ss_dim1];
/* L54: */
	}
/* L55: */
    }
/*     Cholesky factorize T to J*J' with */
/*        J' stored in the upper triangle of wt. */
    dpofa_(&wt[wt_offset], m, col, info);
    if (*info != 0) {
	*info = -3;
    }
    return 0;
} /* formt_ */

/* ======================= The end of formt ============================== */
/* Subroutine */ int freev_(int *n, int *nfree, int *index, 
	int *nenter, int *ileave, int *indx2, int *iwhere, 
	logical *wrk, logical *updatd, logical *cnstnd, int *iprint, 
	int *iter)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int iact, i, k;

    /* Parameter adjustments */
    --index;
    --indx2;
    --iwhere;

    /* Function Body */
/*     ************ */

/*     Subroutine freev */

/*     This subroutine counts the entering and leaving variables when */
/*       iter > 0, and finds the index set of free and active variables */

/*       at the GCP. */

/*     cnstnd is a logical variable indicating whether bounds are present 
*/

/*     index is an int array of dimension n */
/*       for i=1,...,nfree, index(i) are the indices of free variables */
/*       for i=nfree+1,...,n, index(i) are the indices of bound variables 
*/
/*       On entry after the first iteration, index gives */
/*         the free variables at the previous iteration. */
/*       On exit it gives the free variables based on the determination */

/*         in cauchy using the array iwhere. */

/*     indx2 is an int array of dimension n */
/*       On entry indx2 is unspecified. */
/*       On exit with iter>0, indx2 indicates which variables */
/*          have changed status since the previous iteration. */
/*       For i= 1,...,nenter, indx2(i) have changed from bound to free. */

/*       For i= ileave+1,...,n, indx2(i) have changed from free to bound. 
*/


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    *nenter = 0;
    *ileave = *n + 1;
    if (*iter > 0 && *cnstnd) {
/*                           count the entering and leaving 
variables. */
	i_1 = *nfree;
	for (i = 1; i <= i_1; ++i) {
	    k = index[i];
	    if (iwhere[k] > 0) {
		--(*ileave);
		indx2[*ileave] = k;
		if (*iprint >= 100) {
		  fprintf(stdout,
			  "Variable %d leaves the set of free variables\n",k);
		}
	    }
/* L20: */
	}
	i_1 = *n;
	for (i = *nfree + 1; i <= i_1; ++i) {
	    k = index[i];
	    if (iwhere[k] <= 0) {
		++(*nenter);
		indx2[*nenter] = k;
		if (*iprint >= 100) {
		  fprintf(stdout,
			  "Variable %d enters the set of free variables\n",k);
		}
	    }
/* L22: */
	}
	if (*iprint >= 99) {
	  i_1 = *n + 1 - *ileave;
	  fprintf(stdout,"%d variables leave; %d variables enter\n",
		i_1, *nenter);  
	}
    }
    *wrk = *ileave < *n + 1 || *nenter > 0 || *updatd;
/*     Find the index set of free and active variables at the GCP. */
    *nfree = 0;
    iact = *n + 1;
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	if (iwhere[i] <= 0) {
	    ++(*nfree);
	    index[*nfree] = i;
	} else {
	    --iact;
	    index[iact] = i;
	}
/* L24: */
    }
    if (*iprint >= 99) {
      i_1 = *iter + 1;
      fprintf(stdout,"%d variables are free at GCP %d\n",
	      *nfree,i_1);
    }
    return 0;
} /* freev_ */

/* ======================= The end of freev ============================== */
/* Subroutine */ int hpsolb_(int *n, double *t, int *iorder, 
	int *iheap)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    double ddum;
    int i, j, k, indxin, indxou;
    double out;

    /* Parameter adjustments */
    --t;
    --iorder;

    /* Function Body */
/*     ************ */

/*     Subroutine hpsolb */

/*     This subroutine sorts out the least element of t, and puts the */
/*       remaining elements of t in a heap. */

/*     n is an int variable. */
/*       On entry n is the dimension of the arrays t and iorder. */
/*       On exit n is unchanged. */

/*     t is a double precision array of dimension n. */
/*       On entry t stores the elements to be sorted, */
/*       On exit t(n) stores the least elements of t, and t(1) to t(n-1) 
*/
/*         stores the remaining elements in the form of a heap. */

/*     iorder is an int array of dimension n. */
/*       On entry iorder(i) is the index of t(i). */
/*       On exit iorder(i) is still the index of t(i), but iorder may be 
*/
/*         permuted in accordance with t. */

/*     iheap is an int variable specifying the task. */
/*       On entry iheap should be set as follows: */
/*         iheap .eq. 0 if t(1) to t(n) is not in the form of a heap, */
/*         iheap .ne. 0 if otherwise. */
/*       On exit iheap is unchanged. */


/*     References: */
/*       Algorithm 232 of CACM (J. W. J. Williams): HEAPSORT. */

/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */

/*     ************ */
    if (*iheap == 0) {
/*        Rearrange the elements t(1) to t(n) to form a heap. */
	i_1 = *n;
	for (k = 2; k <= i_1; ++k) {
	    ddum = t[k];
	    indxin = iorder[k];
/*           Add ddum to the heap. */
	    i = k;
L10:
	    if (i > 1) {
		j = i / 2;
		if (ddum < t[j]) {
		    t[i] = t[j];
		    iorder[i] = iorder[j];
		    i = j;
		    goto L10;
		}
	    }
	    t[i] = ddum;
	    iorder[i] = indxin;
/* L20: */
	}
    }
/*     Assign to 'out' the value of t(1), the least member of the heap, */

/*        and rearrange the remaining members to form a heap as */
/*        elements 1 to n-1 of t. */
    if (*n > 1) {
	i = 1;
	out = t[1];
	indxou = iorder[1];
	ddum = t[*n];
	indxin = iorder[*n];
/*        Restore the heap */
L30:
	j = i + i;
	if (j <= *n - 1) {
	    if (t[j + 1] < t[j]) {
		++j;
	    }
	    if (t[j] < ddum) {
		t[i] = t[j];
		iorder[i] = iorder[j];
		i = j;
		goto L30;
	    }
	}
	t[i] = ddum;
	iorder[i] = indxin;
/*     Put the least member in t(n). */
	t[*n] = out;
	iorder[*n] = indxou;
    }
    return 0;
} /* hpsolb_ */

/* ====================== The end of hpsolb ============================== */
/* Subroutine */ int lnsrlb_(int *n, double *l, double *u, 
	int *nbd, double *x, double *f, double *fold, 
	double *gd, double *gdold, double *g, double *d, 
	double *r, double *t, double *z, double *stp, 
	double *dnorm, double *dtd, double *xstep, double *
	stpmx, int *iter, int *ifun, int *iback, int *nfgv, 
	int *info, char *task, logical *boxed, logical *cnstnd, char *
	csave, int *isave, double *dsave, ftnlen task_len, ftnlen 
	csave_len)
{
    /* System generated locals */
    int i_1;
    double d_1;

    /* Builtin functions */
    double sqrt(double);

    /* Local variables */
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    int i;
    extern /* Subroutine */ int dcopy_(int *, double *, int *, 
	    double *, int *);
    double a1, a2;
    extern /* Subroutine */ int dcsrch_(double *, double *, 
	    double *, double *, double *, double *, 
	    double *, double *, char *, int *, double *, 
	    ftnlen);

    /* Parameter adjustments */
    --l;
    --u;
    --nbd;
    --x;
    --g;
    --d;
    --r;
    --t;
    --z;
    --isave;
    --dsave;

    /* Function Body */
/*     ********** */

/*     Subroutine lnsrlb */

/*     This subroutine calls subroutine dcsrch from the Minpack2 library 
*/
/*       to perform the line search.  Subroutine dscrch is safeguarded so 
*/
/*       that all trial points lie within the feasible region. */

/*     Subprograms called: */

/*       Minpack2 Library ... dcsrch. */

/*       Linpack ... dtrsl, ddot. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ********** */
    if (lcl_s_cmp(task, "FG_LN", 5L, 5L) == 0) {
	goto L556;
    }
    *dtd = ddot_(n, &d[1], &c__1, &d[1], &c__1);
    *dnorm = sqrt(*dtd);
/*     Determine the maximum step length. */
    *stpmx = 1e10;
    if (*cnstnd) {
	if (*iter == 0) {
	    *stpmx = 1.;
	} else {
	    i_1 = *n;
	    for (i = 1; i <= i_1; ++i) {
		a1 = d[i];
		if (nbd[i] != 0) {
		    if (a1 < 0. && nbd[i] <= 2) {
			a2 = l[i] - x[i];
			if (a2 >= 0.) {
			    *stpmx = 0.;
			} else if (a1 * *stpmx < a2) {
			    *stpmx = a2 / a1;
			}
		    } else if (a1 > 0. && nbd[i] >= 2) {
			a2 = u[i] - x[i];
			if (a2 <= 0.) {
			    *stpmx = 0.;
			} else if (a1 * *stpmx > a2) {
			    *stpmx = a2 / a1;
			}
		    }
		}
/* L43: */
	    }
	}
    }
    if (*iter == 0 && ! (*boxed)) {
/* Computing MAX */
	d_1 = 1. / *dnorm;
	*stp = min(*stpmx,d_1);
    } else {
	*stp = 1.;
    }
    dcopy_(n, &x[1], &c__1, &t[1], &c__1);
    dcopy_(n, &g[1], &c__1, &r[1], &c__1);
    *fold = *f;
    *ifun = 0;
    *iback = 0;
    lcl_s_copy(csave, "START", 60L, 5L);
L556:
    *gd = ddot_(n, &g[1], &c__1, &d[1], &c__1);
    if (*ifun == 0) {
	*gdold = *gd;
	if (*gd >= 0.) {
/*                               the directional derivative >=0. 
*/
/*                               Line search is impossible. */
	    *info = -4;
	    return 0;
	}
    }
    dcsrch_(f, gd, stp, &c_b275, &c_b276, &c_b277, &c_b9, stpmx, csave, &
	    isave[1], &dsave[1], 60L);
    *xstep = *stp * *dnorm;
    if (lcl_s_cmp(csave, "CONV", 4L, 4L) != 0 && lcl_s_cmp(csave, "WARN", 4L, 4L) != 
	    0) {
	lcl_s_copy(task, "FG_LNSRCH", 60L, 9L);
	++(*ifun);
	++(*nfgv);
	*iback = *ifun - 1;
	if (*stp == 1.) {
	    dcopy_(n, &z[1], &c__1, &x[1], &c__1);
	} else {
	    i_1 = *n;
	    for (i = 1; i <= i_1; ++i) {
		x[i] = *stp * d[i] + t[i];
/* L41: */
	    }
	}
    } else {
	lcl_s_copy(task, "NEW_X", 60L, 5L);
    }
    return 0;
} /* lnsrlb_ */

/* ======================= The end of lnsrlb ============================= */
/* Subroutine */ int matupd_(int *n, int *m, double *ws, 
	double *wy, double *sy, double *ss, double *d, 
	double *r, int *itail, int *iupdat, int *col, int 
	*head, double *theta, double *rr, double *dr, double *
	stp, double *dtd)
{
    /* System generated locals */
    int ws_dim1, ws_offset, wy_dim1, wy_offset, sy_dim1, sy_offset, 
	    ss_dim1, ss_offset, i_1, i_2;

    /* Local variables */
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    int j;
    extern /* Subroutine */ int dcopy_(int *, double *, int *, 
	    double *, int *);
    int pointr;

    /* Parameter adjustments */
    ws_dim1 = *n;
    ws_offset = ws_dim1 + 1;
    ws -= ws_offset;
    wy_dim1 = *n;
    wy_offset = wy_dim1 + 1;
    wy -= wy_offset;
    sy_dim1 = *m;
    sy_offset = sy_dim1 + 1;
    sy -= sy_offset;
    ss_dim1 = *m;
    ss_offset = ss_dim1 + 1;
    ss -= ss_offset;
    --d;
    --r;

    /* Function Body */
/*     ************ */

/*     Subroutine matupd */

/*       This subroutine updates matrices WS and WY, and forms the */
/*         middle matrix in B. */

/*     Subprograms called: */

/*       Linpack ... dcopy, ddot. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*     Set pointers for matrices WS and WY. */
    if (*iupdat <= *m) {
	*col = *iupdat;
	*itail = (*head + *iupdat - 2) % *m + 1;
    } else {
	*itail = *itail % *m + 1;
	*head = *head % *m + 1;
    }
/*     Update matrices WS and WY. */
    dcopy_(n, &d[1], &c__1, &ws[*itail * ws_dim1 + 1], &c__1);
    dcopy_(n, &r[1], &c__1, &wy[*itail * wy_dim1 + 1], &c__1);
/*     Set theta=yy/ys. */
    *theta = *rr / *dr;
/*     Form the middle matrix in B. */
/*        update the upper triangle of SS, */
/*                                         and the lower triangle of SY: 
*/
    if (*iupdat > *m) {
/*                              move old information */
	i_1 = *col - 1;
	for (j = 1; j <= i_1; ++j) {
	    dcopy_(&j, &ss[(j + 1) * ss_dim1 + 2], &c__1, &ss[j * ss_dim1 + 1]
		    , &c__1);
	    i_2 = *col - j;
	    dcopy_(&i_2, &sy[j + 1 + (j + 1) * sy_dim1], &c__1, &sy[j + j * 
		    sy_dim1], &c__1);
/* L50: */
	}
    }
/*        add new information: the last row of SY */
/*                                             and the last column of SS: 
*/
    pointr = *head;
    i_1 = *col - 1;
    for (j = 1; j <= i_1; ++j) {
	sy[*col + j * sy_dim1] = ddot_(n, &d[1], &c__1, &wy[pointr * wy_dim1 
		+ 1], &c__1);
	ss[j + *col * ss_dim1] = ddot_(n, &ws[pointr * ws_dim1 + 1], &c__1, &
		d[1], &c__1);
	pointr = pointr % *m + 1;
/* L51: */
    }
    if (*stp == 1.) {
	ss[*col + *col * ss_dim1] = *dtd;
    } else {
	ss[*col + *col * ss_dim1] = *stp * *stp * *dtd;
    }
    sy[*col + *col * sy_dim1] = *dr;
    return 0;
} /* matupd_ */

/* ======================= The end of matupd ============================= */
/* Subroutine */ int prn1lb_(int *n, int *m, double *l, 
	double *u, double *x, int *iprint, int *itfile, 
	double *epsmch)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int i;

    /* Parameter adjustments */
    --l;
    --u;
    --x;

    if (*iprint == 0) {
      fprintf(stdout,"RUNNING THE L-BFGS-B CODE\n\n  * * *\n\n");
      fprintf(stdout,"Machine precision= %e",*epsmch);
      fprintf(stdout," N = %d    M = %d\n",*n,*m);
    }
    else if (*iprint >= 1) {
      fprintf(stdout,"RUNNING THE L-BFGS-B CODE\n\n");
      fprintf(stdout,"it    = iteration number\n");
      fprintf(stdout,"nf    = number of function evaluations\n");
      fprintf(stdout,
	      "nint  = number of segments explored during the Cauchy search\n");
      fprintf(stdout,
	      "nact  = number of active bounds at the generalized Cauchy point\n");
      fprintf(stdout,
	      "sub   = manner in which the subspace minimization terminated:\n");
      fprintf(stdout,
	      "     con = converged, bnd = a bound was reached\n");
      fprintf(stdout,
	      "itls  = number of iterations performed in the line search\n");
      fprintf(stdout,"stepl = step length used\n");
      fprintf(stdout,"tstep = norm of the displacement (total step)\n");
      fprintf(stdout,"projg = norm of the projected gradient\n");
      fprintf(stdout,"f     = function value\n");
      fprintf(stdout,"        * * *\n");
      fprintf(stdout,"Machine precision = %e\n",*epsmch);
      if (*iprint > 100) {
	i_1 = *n;
	fprintf(stdout,"L = ");
	for (i = 1; i <= i_1; ++i) {
	  fprintf(stdout,"%lg ",l[i]);
	}
	fprintf(stdout,"\n");
	i_1 = *n;
	fprintf(stdout,"X0 = ");
	for (i = 1; i <= i_1; ++i) {
	  fprintf(stdout,"%lg ",x[i]);
	}
	fprintf(stdout,"\n");
	i_1 = *n;
	fprintf(stdout,"U = ");
	for (i = 1; i <= i_1; ++i) {
	  fprintf(stdout,"%lg ",u[i]);
	}
	fprintf(stdout,"\n");
      }
    }
    return 0;
} /* prn1lb_ */

/* ======================= The end of prn1lb ============================= */
/* Subroutine */ int prn2lb_(int *n, double *x, double *f, 
			     double *g, int *iprint, int *itfile, int *iter, 
			     int *nfgv, int *nact, double *sbgnrm, int *nint, char 
			     *word, int *iword, int *iback, double *stp, double *
			     xstep, ftnlen word_len)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int imod, i;

    /* Parameter adjustments */
    --x;
    --g;

    /* Function Body */
/*     ************ */

/*     Subroutine prn2lb */

/*     This subroutine prints out new information after a successful */
/*       line search. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
/*           'word' records the status of subspace solutions. */
    if (*iword == 0) {
/*                            the subspace minimization converged. */
	lcl_s_copy(word, "con", 3L, 3L);
    } else if (*iword == 1) {
/*                          the subspace minimization stopped at a 
bound. */
	lcl_s_copy(word, "bnd", 3L, 3L);
    } else if (*iword == 5) {
/*                             the truncated Newton step has been 
used. */
	lcl_s_copy(word, "TNT", 3L, 3L);
    } else {
	lcl_s_copy(word, "---", 3L, 3L);
    }
    if (*iprint >= 99) {
      fprintf(stdout,"LINE SEARCH %d times; norm of step = %lf\n",
	      *iback, *xstep);
      fprintf(stdout,"at iterate %d     f= %lf     |proj g|= %lf\n",
	      *iter, *f, *sbgnrm);
      if (*iprint > 100) {
	i_1 = *n;
 	fprintf(stdout,"X = ");
	for (i = 1; i <= i_1; ++i) {
	  fprintf(stdout,"%lf ",x[i]);
	}
	fprintf(stdout,"\n");
	
	i_1 = *n;
	fprintf(stdout,"G = ");
	for (i = 1; i <= i_1; ++i) {
	  fprintf(stdout,"%lf ",g[i]);
	}
	fprintf(stdout,"\n");
      }
    } else if (*iprint > 0) {
      imod = *iter % *iprint;
      if (imod == 0) {
	fprintf(stdout,"at iterate %d     f= %lf     |proj g|= %lf\n",
		*iter, *f, *sbgnrm);
      }
    }
    if (*iprint >= 1) {
      fprintf(stdout,"%d %d %d %d %c%c%c %d %lf %lf %lf %lf\n",
	      *iter,*nfgv,*nint,*nact,word[0],word[1],word[2],
	      *iback,*stp,*xstep,*sbgnrm,*f);
    }
    return 0;
} /* prn2lb_ */

/* ======================= The end of prn2lb ============================= */
/* Subroutine */ int prn3lb_(int *n, double *x, double *f, char *
	task, int *iprint, int *info, int *itfile, int *iter, 
	int *nfgv, int *nintol, int *nskip, int *nact, 
	double *sbgnrm, double *time, int *nint, char *word, 
	int *iback, double *stp, double *xstep, int *k, 
	double *cachyt, double *sbtime, double *lnscht, ftnlen 
	task_len, ftnlen word_len)
{
  /* System generated locals */
  int i_1;
  
  /* Local variables */
  int i;
  
  /* Parameter adjustments */
  --x;
  
  /* Function Body */
  /*     ************ */
  
  /*     Subroutine prn3lb */
  
  /*     This subroutine prints out information when either a built-in */
  /*       convergence test is satisfied or when an error message is */
  /*       generated. */
  
  
  /*                           *  *  * */
  
  /*     NEOS, November 1994. (Latest revision April 1997.) */
  /*     Optimization Technology Center. */
  /*     Argonne National Laboratory and Northwestern University. */
  /*     Written by */
  /*                        Ciyou Zhu */
  /*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */
  
  
  /*     ************ */
  if (lcl_s_cmp(task, "ERROR", 5L, 5L) == 0) {
    goto L999;
  }
  if (*iprint >= 0) {
    fprintf(stdout,"\n");
    fprintf(stdout,"           * * *\n\n");
    fprintf(stdout,"Tit   = total number of iterations\n");
    fprintf(stdout,"Tnf   = total number of function evaluations\n");
    fprintf(stdout,"Tnint = total number of segments explored during\n");
    fprintf(stdout," Cauchy searches\n");
    fprintf(stdout,"Skip  = number of BFGS updates skipped\n");
    fprintf(stdout,"Nact  = number of active bounds at final generalized\n");
    fprintf(stdout," Cauchy point\n");
    fprintf(stdout,"Projg = norm of the final projected gradient\n");
    fprintf(stdout,"F     = final function value\n");
    fprintf(stdout,"           * * *\n");
    fprintf(stdout,"\n\n");
    fprintf(stdout,
	    "   N   Tit  Tnf  Tnint  Skip  Nact     Projg        F\n");
    fprintf(stdout,
	    "%5d  %4d %4d %6d  %4d %5d       %10.3f %10.3f\n",
	    *n,*iter,*nfgv,*nintol,*nskip,*nact,*sbgnrm,*f);
    if (*iprint >= 100) {
      i_1 = *n;
      fprintf(stdout,"X = ");
      for (i = 1; i <= i_1; ++i) {
	fprintf(stdout,"%lf ",x[i]);
      }
      fprintf(stdout,"\n");
    }
    if (*iprint >= 1) {
      fprintf(stdout,"F= %lf\n",*f);
    }
  }
L999:
  if (*iprint >= 0) {
    fprintf(stdout,"%s\n",task);
    if (*info != 0) {
      if (*info == -1) {
	fprintf(stdout,
		" Matrix in 1st Cholesky factorization in formk is not Pos. Def.\n");
      }
      if (*info == -2) {
	fprintf(stdout,
		" Matrix in 2st Cholesky factorization in formk is not Pos. Def.\n");
      }
      if (*info == -3) {
	fprintf(stdout,
		" Matrix in the Cholesky factorization in formt is not Pos. Def.\n");
      }
      if (*info == -4) {
	fprintf(stdout,
		" Derivative >= 0, backtracking line search impossible.\n");
	fprintf(stdout,
		" Possible causes: 1 error in function or gradient evaluation;\n");
	fprintf(stdout,
		"                  2 rounding errors dominate computation.\n");
      }
      if (*info == -5) {
	fprintf(stdout,
		" Warning:  more than 10 function and gradient\n");
	fprintf(stdout,
		"   evaluations in the last line search.  Termination\n");
	fprintf(stdout,
		"   may possibly be caused by a bad search direction.\n");
      }
      if (*info == -6) {
	fprintf(stdout," Input ndb( %d ) is invalid.\n", *k);
      }
      if (*info == -7) {
	fprintf(stdout,"l( %d ) > u( %d ). No feasible solution.\n",*k,*k);
      }
      if (*info == -8) {
	fprintf(stdout," The triangular system is singular.\n");
      }
      if (*info == -9) {
	fprintf(stdout,
		" Line search cannot locate an adequate point after 20 function\n");
	fprintf(stdout,
		"  and gradient evaluations.  Previous x, f and g restored.\n");
	fprintf(stdout,
		" Possible causes: 1 error in function or gradient evaluation;\n");
	fprintf(stdout,
		"                  2 rounding error dominate computation.\n");
      }
    }
    if (*iprint >= 1) {
      fprintf(stdout," Cauchy                time  %10.3lf seconds.\n",
	      *cachyt);
      fprintf(stdout," Subspace minimization time  %10.3lf seconds.\n",
	      *sbtime);
      fprintf(stdout," Line search           time  %10.3lf seconds.\n",
	      *lnscht);
    }
    fprintf(stdout," Total User            time  %10.3lf seconds.\n",
	    *time);
    if (*iprint >= 1) {
      if (*info == -4 || *info == -9) {
	fprintf(stdout,
		" %4d %5d %5d %5d %c%c%c %4d    %7.1lf  %7.1lf      -          -\n",
		*iter,*nfgv,*nint,*nact,word[0],word[1],word[2],
		*iback,*stp,*xstep);
      }
      fprintf(stdout,"%s\n",task);
#ifdef never
      if (*info != 0) {
	if (*info == -1) {
	  fprintf(stdout,
		  " Matrix in 1st Cholesky factorization in formk is not Pos. Def.\n");
	}
	if (*info == -2) {
	  fprintf(stdout,
		  " Matrix in 2st Cholesky factorization in formk is not Pos. Def.\n");
	}
	if (*info == -3) {
	  fprintf(stdout,
		  " Matrix in the Cholesky factorization in formt is not Pos. Def.\n");
	}
	if (*info == -4) {
	  fprintf(stdout,
		  " Derivative >= 0, backtracking line search impossible.\n");
	  fprintf(stdout,
		  " Possible causes: 1 error in function or gradient evaluation;\n");
	  fprintf(stdout,
		  "                  2 rounding errors dominate computation.\n")
	    }
	if (*info == -5) {
	  fprintf(stdout,
		  " Warning:  more than 10 function and gradient\n");
	  fprintf(stdout,
		  "   evaluations in the last line search.  Termination\n");
	  fprintf(stdout,
		  "   may possibly be caused by a bad search direction.\n");
	}
	if (*info == -8) {
	  fprintf(stdout," The triangular system is singular.\n");
	}
	if (*info == -9) {
	  fprintf(stdout,
		  " Line search cannot locate an adequate point after 20 function\n");
	  fprintf(stdout,
		  "  and gradient evaluations.  Previous x, f and g restored.\n");
	  fprintf(stdout,
		  " Possible causes: 1 error in function or gradient evaluation;\n");
	  fprintf(stdout,
		  "                  2 rounding error dominate computation.\n");
	}
      }
      fprintf(stdout," Total User            time  %10.3lf seconds.\n",
	      *time);
#endif
    }
  }
  return 0;
} /* prn3lb_ */

/* ======================= The end of prn3lb ============================= */
/* Subroutine */ int projgr_(int *n, double *l, double *u, 
			     int *nbd, double *x, double *g, double *sbgnrm)
{
    /* System generated locals */
    int i_1;
    double d_1, d_2;
    
    /* Local variables */
    int i;
    double gi;
    
    /* Parameter adjustments */
    --l;
    --u;
    --nbd;
    --x;
    --g;

    /* Function Body */
/*     ************ */

/*     Subroutine projgr */

/*     This subroutine computes the infinity norm of the projected */
/*       gradient. */


/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision April 1997.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    *sbgnrm = 0.;
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	gi = g[i];
	if (nbd[i] != 0) {
	    if (gi < 0.) {
		if (nbd[i] >= 2) {
/* Computing MAX */
		    d_1 = x[i] - u[i];
		    gi = max(gi,d_1);
		}
	    } else {
		if (nbd[i] <= 2) {
/* Computing MAX */
		    d_1 = x[i] - l[i];
		    gi = min(gi,d_1);
		}
	    }
	}
/* Computing MAX */
	d_1 = *sbgnrm, d_2 = fabs(gi);
	*sbgnrm = max(d_2,d_1);
/* L15: */
    }
    return 0;
} /* projgr_ */

/* ======================= The end of projgr ============================= */
/* Subroutine */ int subsm_(int *n, int *m, int *nsub, int *
	ind, double *l, double *u, int *nbd, double *x, 
	double *d, double *ws, double *wy, double *theta, 
	int *col, int *head, int *iword, double *wv, 
	double *wn, int *iprint, int *info)
{

    /* System generated locals */
    int ws_dim1, ws_offset, wy_dim1, wy_offset, wn_dim1, wn_offset, i_1, 
	    i_2;

    /* Local variables */
    double temp1, temp2;
    int i, j, k;
    double alpha;
    extern /* Subroutine */ int dtrsl_(double *, int *, int *, 
	    double *, int *, int *);
    int m2;
    double dk;
    int js, jy, pointr, ibd, col2;

    /* Parameter adjustments */
    --ind;
    --l;
    --u;
    --nbd;
    --x;
    --d;
    ws_dim1 = *n;
    ws_offset = ws_dim1 + 1;
    ws -= ws_offset;
    wy_dim1 = *n;
    wy_offset = wy_dim1 + 1;
    wy -= wy_offset;
    --wv;
    wn_dim1 = *m << 1;
    wn_offset = wn_dim1 + 1;
    wn -= wn_offset;

    /* Function Body */
/*     ************ */

/*     Subroutine subsm */

/*     Given xcp, l, u, r, an index set that specifies */
/*       It controls the frequency and type of output generated: */
/*        iprint<0    no output is generated; */
/*        iprint=0    print only one line at the last iteration; */
/*        0<iprint<99 print also f and |proj g| every iprint iterations; 
*/
/*        iprint=99   print details of every iteration except n-vectors; 
*/
/*        iprint=100  print also the changes of active set and final x; */

/*        iprint>100  print details of every iteration including x and g; 
*/
/*       When iprint > 0, the file iterate.dat will be created to */
/*                        summarize the iteration. */

/*     info is an int variable. */
/*       On entry info is unspecified. */
/*       On exit info = 0       for normal return, */
/*                    = nonzero for abnormal return */
/*                                  when the matrix K is ill-conditioned. 
*/

/*     Subprograms called: */

/*       Linpack dtrsl. */


/*     References: */

/*       [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited */
/*       memory algorithm for bound constrained optimization'', */
/*       SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208. */




/*                           *  *  * */

/*     NEOS, November 1994. (Latest revision June 1996.) */
/*     Optimization Technology Center. */
/*     Argonne National Laboratory and Northwestern University. */
/*     Written by */
/*                        Ciyou Zhu */
/*     in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal. */


/*     ************ */
    if (*nsub <= 0) {
	return 0;
    }
    if (*iprint >= 99) {
      fprintf(stdout,"----------------SUBSM entered-----------------\n");
    }
/*     Compute wv = W'Zd. */
    pointr = *head;
    i_1 = *col;
    for (i = 1; i <= i_1; ++i) {
	temp1 = 0.;
	temp2 = 0.;
	i_2 = *nsub;
	for (j = 1; j <= i_2; ++j) {
	    k = ind[j];
	    temp1 += wy[k + pointr * wy_dim1] * d[j];
	    temp2 += ws[k + pointr * ws_dim1] * d[j];
/* L10: */
	}
	wv[i] = temp1;
	wv[*col + i] = *theta * temp2;
	pointr = pointr % *m + 1;
/* L20: */
    }
/*     Compute wv:=K^(-1)wv. */
    m2 = *m << 1;
    col2 = *col << 1;
    dtrsl_(&wn[wn_offset], &m2, &col2, &wv[1], &c__11, info);
    if (*info != 0) {
	return 0;
    }
    i_1 = *col;
    for (i = 1; i <= i_1; ++i) {
	wv[i] = -wv[i];
/* L25: */
    }
    dtrsl_(&wn[wn_offset], &m2, &col2, &wv[1], &c__1, info);
    if (*info != 0) {
	return 0;
    }
/*     Compute d = (1/theta)d + (1/theta**2)Z'W wv. */
    pointr = *head;
    i_1 = *col;
    for (jy = 1; jy <= i_1; ++jy) {
	js = *col + jy;
	i_2 = *nsub;
	for (i = 1; i <= i_2; ++i) {
	    k = ind[i];
	    d[i] = d[i] + wy[k + pointr * wy_dim1] * wv[jy] / *theta + ws[k + 
		    pointr * ws_dim1] * wv[js];
/* L30: */
	}
	pointr = pointr % *m + 1;
/* L40: */
    }
    i_1 = *nsub;
    for (i = 1; i <= i_1; ++i) {
	d[i] /= *theta;
/* L50: */
    }
/*     Backtrack to the feasible region. */
    alpha = 1.;
    temp1 = alpha;
    i_1 = *nsub;
    for (i = 1; i <= i_1; ++i) {
	k = ind[i];
	dk = d[i];
	if (nbd[k] != 0) {
	    if (dk < 0. && nbd[k] <= 2) {
		temp2 = l[k] - x[k];
		if (temp2 >= 0.) {
		    temp1 = 0.;
		} else if (dk * alpha < temp2) {
		    temp1 = temp2 / dk;
		}
	    } else if (dk > 0. && nbd[k] >= 2) {
		temp2 = u[k] - x[k];
		if (temp2 <= 0.) {
		    temp1 = 0.;
		} else if (dk * alpha > temp2) {
		    temp1 = temp2 / dk;
		}
	    }
	    if (temp1 < alpha) {
		alpha = temp1;
		ibd = i;
	    }
	}
/* L60: */
    }
    if (alpha < 1.) {
	dk = d[ibd];
	k = ind[ibd];
	if (dk > 0.) {
	    x[k] = u[k];
	    d[ibd] = 0.;
	} else if (dk < 0.) {
	    x[k] = l[k];
	    d[ibd] = 0.;
	}
    }
    i_1 = *nsub;
    for (i = 1; i <= i_1; ++i) {
	k = ind[i];
	x[k] += alpha * d[i];
/* L70: */
    }
    if (*iprint >= 99) {
	if (alpha < 1.) {
	  fprintf(stdout,"ALPHA = %7.5lf backtrack to the BOX\n",alpha);
	} else {
	  fprintf(stdout,"SM solution inside the box\n");
	}
	if (*iprint > 100) {
	  i_1 = *n;
	  fprintf(stdout,"Subspace solution X =  ");
	  for (i = 1; i <= i_1; ++i) {
	    fprintf(stdout," %11.4lf",x[i]);
	  }
	  fprintf(stdout,"\n");
	}
    }
    if (alpha < 1.) {
	*iword = 1;
    } else {
	*iword = 0;
    }
    if (*iprint >= 99) {
      fprintf(stdout,"----------------exit SUBSM --------------------\n");
    }
    return 0;
} /* subsm_ */

/* ====================== The end of subsm =============================== */
/* Subroutine */ int dcsrch_(double *f, double *g, double *stp, 
	double *ftol, double *gtol, double *xtol, double *
	stpmin, double *stpmax, char *task, int *isave, double *
	dsave, ftnlen task_len)
{
    /* System generated locals */
    double d_1;

    /* Local variables */
    int stage;
    double finit, ginit, width, ftest, gtest, stmin, stmax, width1, fm, 
	    gm, fx, fy, gx, gy;
    logical brackt;
    extern /* Subroutine */ int dcstep_(double *, double *, 
	    double *, double *, double *, double *, 
	    double *, double *, double *, logical *, double *,
	     double *);
    double fxm, fym, gxm, gym, stx, sty;

    /* Parameter adjustments */
    --isave;
    --dsave;

    /* Function Body */
/*     ********** */

/*     Subroutine dcsrch */

/*     This subroutine finds a step that satisfies a sufficient */
/*            input arguments. */

/*         On exit with convergence, a warning or an error, the */
/*            variable task contains additional information. */

/*       isave is an int work array of dimension 2. */

/*       dsave is a double precision work array of dimension 13. */

/*     Subprograms called */

/*       MINPACK-2 ... dcstep */

/*     MINPACK-1 Project. June 1983. */
/*     Argonne National Laboratory. */
/*     Jorge J. More' and David J. Thuente. */

/*     MINPACK-2 Project. October 1993. */
/*     Argonne National Laboratory and University of Minnesota. */
/*     Brett M. Averick, Richard G. Carter, and Jorge J. More'. */

/*     ********** */
/*     Initialization block. */
    if (lcl_s_cmp(task, "START", 5L, 5L) == 0) {
/*        Check the input arguments for errors. */
	if (*stp < *stpmin) {
	    lcl_s_copy(task, "ERROR: STP .LT. STPMIN", task_len, 22L);
	}
	if (*stp > *stpmax) {
	    lcl_s_copy(task, "ERROR: STP .GT. STPMAX", task_len, 22L);
	}
	if (*g >= 0.) {
	    lcl_s_copy(task, "ERROR: INITIAL G .GE. ZERO", task_len, 26L);
	}
	if (*ftol < 0.) {
	    lcl_s_copy(task, "ERROR: FTOL .LT. ZERO", task_len, 21L);
	}
	if (*gtol < 0.) {
	    lcl_s_copy(task, "ERROR: GTOL .LT. ZERO", task_len, 21L);
	}
	if (*xtol < 0.) {
	    lcl_s_copy(task, "ERROR: XTOL .LT. ZERO", task_len, 21L);
	}
	if (*stpmin < 0.) {
	    lcl_s_copy(task, "ERROR: STPMIN .LT. ZERO", task_len, 23L);
	}
	if (*stpmax < *stpmin) {
	    lcl_s_copy(task, "ERROR: STPMAX .LT. STPMIN", task_len, 25L);
	}
/*        Exit if there are errors on input. */
	if (lcl_s_cmp(task, "ERROR", 5L, 5L) == 0) {
	    return 0;
	}
/*        Initialize local variables. */
	brackt = FALSE_;
	stage = 1;
	finit = *f;
	ginit = *g;
	gtest = *ftol * ginit;
	width = *stpmax - *stpmin;
	width1 = width / .5;
/*        The variables stx, fx, gx contain the values of the step, */

/*        function, and derivative at the best step. */
/*        The variables sty, fy, gy contain the value of the step, */
/*        function, and derivative at sty. */
/*        The variables stp, f, g contain the values of the step, */
/*        function, and derivative at stp. */
	stx = 0.;
	fx = finit;
	gx = ginit;
	sty = 0.;
	fy = finit;
	gy = ginit;
	stmin = 0.;
	stmax = *stp + *stp * 4.;
	lcl_s_copy(task, "FG", task_len, 2L);
	goto L1000;
    } else {
/*        Restore local variables. */
	if (isave[1] == 1) {
	    brackt = TRUE_;
	} else {
	    brackt = FALSE_;
	}
	stage = isave[2];
	ginit = dsave[1];
	gtest = dsave[2];
	gx = dsave[3];
	gy = dsave[4];
	finit = dsave[5];
	fx = dsave[6];
	fy = dsave[7];
	stx = dsave[8];
	sty = dsave[9];
	stmin = dsave[10];
	stmax = dsave[11];
	width = dsave[12];
	width1 = dsave[13];
    }
/*     If psi(stp) <= 0 and f'(stp) >= 0 for some step, then the */
/*     algorithm enters the second stage. */
    ftest = finit + *stp * gtest;
    if (stage == 1 && *f <= ftest && *g >= 0.) {
	stage = 2;
    }
/*     Test for warnings. */
    if (brackt && (*stp <= stmin || *stp >= stmax)) {
	lcl_s_copy(task, "WARNING: ROUNDING ERRORS PREVENT PROGRESS", task_len, 
		41L);
    }
    if (brackt && stmax - stmin <= *xtol * stmax) {
	lcl_s_copy(task, "WARNING: XTOL TEST SATISFIED", task_len, 28L);
    }
    if (*stp == *stpmax && *f <= ftest && *g <= gtest) {
	lcl_s_copy(task, "WARNING: STP = STPMAX", task_len, 21L);
    }
    if (*stp == *stpmin && (*f > ftest || *g >= gtest)) {
	lcl_s_copy(task, "WARNING: STP = STPMIN", task_len, 21L);
    }
/*     Test for convergence. */
    if (*f <= ftest && fabs(*g) <= *gtol * (-ginit)) {
	lcl_s_copy(task, "CONVERGENCE", task_len, 11L);
    }
/*     Test for termination. */
    if (lcl_s_cmp(task, "WARN", 4L, 4L) == 0 || lcl_s_cmp(task, "CONV", 4L, 4L) == 0) 
	    {
	goto L1000;
    }
/*     A modified function is used to predict the step during the */
/*     first stage if a lower function value has been obtained but */
/*     the decrease is not sufficient. */
    if (stage == 1 && *f <= fx && *f > ftest) {
/*        Define the modified function and derivative values. */
	fm = *f - *stp * gtest;
	fxm = fx - stx * gtest;
	fym = fy - sty * gtest;
	gm = *g - gtest;
	gxm = gx - gtest;
	gym = gy - gtest;
/*        Call dcstep to update stx, sty, and to compute the new 
step. */
	dcstep_(&stx, &fxm, &gxm, &sty, &fym, &gym, stp, &fm, &gm, &brackt, &
		stmin, &stmax);
/*        Reset the function and derivative values for f. */
	fx = fxm + stx * gtest;
	fy = fym + sty * gtest;
	gx = gxm + gtest;
	gy = gym + gtest;
    } else {
/*       Call dcstep to update stx, sty, and to compute the new step. 
*/
	dcstep_(&stx, &fx, &gx, &sty, &fy, &gy, stp, f, g, &brackt, &stmin, &
		stmax);
    }
/*     Decide if a bisection step is needed. */
    if (brackt) {
	if ((d_1 = sty - stx, fabs(d_1)) >= width1 * .66) {
	    *stp = stx + (sty - stx) * .5;
	}
	width1 = width;
	width = (d_1 = sty - stx, fabs(d_1));
    }
/*     Set the minimum and maximum steps allowed for stp. */
    if (brackt) {
	stmin = min(stx,sty);
	stmax = max(stx,sty);
    } else {
	stmin = *stp + (*stp - stx) * 1.1;
	stmax = *stp + (*stp - stx) * 4.;
    }
/*     Force the step to be within the bounds stpmax and stpmin. */
    *stp = max(*stp,*stpmin);
    *stp = min(*stp,*stpmax);
/*     If further progress is not possible, let stp be the best */
/*     point obtained during the search. */
    if (brackt && (*stp <= stmin || *stp >= stmax) || brackt && stmax - stmin 
	    <= *xtol * stmax) {
	*stp = stx;
    }
/*     Obtain another function and derivative. */
    lcl_s_copy(task, "FG", task_len, 2L);
L1000:
/*     Save local variables. */
    if (brackt) {
	isave[1] = 1;
    } else {
	isave[1] = 0;
    }
    isave[2] = stage;
    dsave[1] = ginit;
    dsave[2] = gtest;
    dsave[3] = gx;
    dsave[4] = gy;
    dsave[5] = finit;
    dsave[6] = fx;
    dsave[7] = fy;
    dsave[8] = stx;
    dsave[9] = sty;
    dsave[10] = stmin;
    dsave[11] = stmax;
    dsave[12] = width;
    dsave[13] = width1;
    return 0;
} /* dcsrch_ */

/* ====================== The end of dcsrch ============================== */
/* Subroutine */ int dcstep_(double *stx, double *fx, double *dx, 
	double *sty, double *fy, double *dy, double *stp, 
	double *fp, double *dp, logical *brackt, double *stpmin, 
	double *stpmax)
{
    /* System generated locals */
    double d_1, d_2, d_3;

    /* Builtin functions */
    double sqrt(double);

    /* Local variables */
    double sgnd, stpc, stpf, stpq, p, q, gamma, r, s, theta;

/*     ********** */

/*     Subroutine dcstep */

/*     This subroutine computes a safeguarded step for a search */
/*     procedure and updates an interval that contains a step that */
/*     satisfies a sufficient decrease and a curvature condition. */

/*     The parameter stx contains the step with the least function */
/*     value. If brackt is set to .true. then a minimizer has */
/*     been bracketed in an interval with endpoints stx and sty. */
/*     The parameter stp contains the current step. */
/*     The subroutine assumes that if brackt is set to .true. then */

/*           min(stx,sty) < stp < max(stx,sty), */

/*     and that the derivative at stx is negative in the direction */
/*     of the step. */

/*     The subroutine statement is */

/*       subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt, */
/*                         stpmin,stpmax) */

/*     where */

/*       stx is a double precision variable. */
/*         On entry stx is the best step obtained so far and is an */
/*            endpoint of the interval that contains the minimizer. */
/*         On exit stx is the updated best step. */

/*       fx is a double precision variable. */
/*         On entry fx is the function at stx. */
/*         On exit fx is the function at stx. */

/*       dx is a double precision variable. */
/*         On entry dx is the derivative of the function at */
/*            stx. The derivative must be negative in the direction of */
/*            the step, that is, dx and stp - stx must have opposite */
/*            signs. */
/*         On exit dx is the derivative of the function at stx. */

/*       sty is a double precision variable. */
/*         On entry sty is the second endpoint of the interval that */
/*            contains the minimizer. */
/*         On exit sty is the updated endpoint of the interval that */
/*            contains the minimizer. */

/*       fy is a double precision variable. */
/*         On entry fy is the function at sty. */
/*         On exit fy is the function at sty. */

/*       dy is a double precision variable. */
/*         On entry dy is the derivative of the function at sty. */
/*         On exit dy is the derivative of the function at the exit sty. 
*/

/*       stp is a double precision variable. */
/*         On entry stp is the current step. If brackt is set to .true. */

/*            then on input stp must be between stx and sty. */
/*         On exit stp is a new trial step. */

/*       fp is a double precision variable. */
/*         On entry fp is the function at stp */
/*         On exit fp is unchanged. */

/*       dp is a double precision variable. */
/*         On entry dp is the the derivative of the function at stp. */
/*         On exit dp is unchanged. */

/*       brackt is an logical variable. */
/*         On entry brackt specifies if a minimizer has been bracketed. */

/*            Initially brackt must be set to .false. */
/*         On exit brackt specifies if a minimizer has been bracketed. */
/*            When a minimizer is bracketed brackt is set to .true. */

/*       stpmin is a double precision variable. */
/*         On entry stpmin is a lower bound for the step. */
/*         On exit stpmin is unchanged. */

/*       stpmax is a double precision variable. */
/*         On entry stpmax is an upper bound for the step. */
/*         On exit stpmax is unchanged. */

/*     MINPACK-1 Project. June 1983 */
/*     Argonne National Laboratory. */
/*     Jorge J. More' and David J. Thuente. */

/*     MINPACK-2 Project. October 1993. */
/*     Argonne National Laboratory and University of Minnesota. */
/*     Brett M. Averick and Jorge J. More'. */

/*     ********** */
    sgnd = *dp * (*dx / fabs(*dx));
/*     First case: A higher function value. The minimum is bracketed. */
/*     If the cubic step is closer to stx than the quadratic step, the */
/*     cubic step is taken, otherwise the average of the cubic and */
/*     quadratic steps is taken. */
    if (*fp > *fx) {
	theta = (*fx - *fp) * 3. / (*stp - *stx) + *dx + *dp;
/* Computing MAX */
	d_1 = fabs(theta), d_2 = fabs(*dx), d_1 = max(d_2,d_1), d_2 = fabs(*dp);
	s = max(d_2,d_1);
/* Computing 2nd power */
	d_1 = theta / s;
	gamma = s * sqrt(d_1 * d_1 - *dx / s * (*dp / s));
	if (*stp < *stx) {
	    gamma = -gamma;
	}
	p = gamma - *dx + theta;
	q = gamma - *dx + gamma + *dp;
	r = p / q;
	stpc = *stx + r * (*stp - *stx);
	stpq = *stx + *dx / ((*fx - *fp) / (*stp - *stx) + *dx) / 2. * (*stp 
		- *stx);
	if ((d_1 = stpc - *stx, fabs(d_1)) < (d_2 = stpq - *stx, fabs(d_2))) {
	    stpf = stpc;
	} else {
	    stpf = stpc + (stpq - stpc) / 2.;
	}
	*brackt = TRUE_;
/*     Second case: A lower function value and derivatives of 
opposite */
/*     sign. The minimum is bracketed. If the cubic step is farther 
from */
/*     stp than the secant step, the cubic step is taken, otherwise 
the */
/*     secant step is taken. */
    } else if (sgnd < 0.) {
	theta = (*fx - *fp) * 3. / (*stp - *stx) + *dx + *dp;
/* Computing MAX */
	d_1 = fabs(theta), d_2 = fabs(*dx), d_1 = max(d_2,d_1), d_2 = fabs(*dp);
	s = max(d_2,d_1);
/* Computing 2nd power */
	d_1 = theta / s;
	gamma = s * sqrt(d_1 * d_1 - *dx / s * (*dp / s));
	if (*stp > *stx) {
	    gamma = -gamma;
	}
	p = gamma - *dp + theta;
	q = gamma - *dp + gamma + *dx;
	r = p / q;
	stpc = *stp + r * (*stx - *stp);
	stpq = *stp + *dp / (*dp - *dx) * (*stx - *stp);
	if ((d_1 = stpc - *stp, fabs(d_1)) > (d_2 = stpq - *stp, fabs(d_2))) {
	    stpf = stpc;
	} else {
	    stpf = stpq;
	}
	*brackt = TRUE_;
/*     Third case: A lower function value, derivatives of the same 
sign, */
/*     and the magnitude of the derivative decreases. */
    } else if (fabs(*dp) < fabs(*dx)) {
/*        The cubic step is computed only if the cubic tends to 
infinity */
/*        in the direction of the step or if the minimum of the cubic 
*/
/*        is beyond stp. Otherwise the cubic step is defined to be 
the */
/*        secant step. */
	theta = (*fx - *fp) * 3. / (*stp - *stx) + *dx + *dp;
/* Computing MAX */
	d_1 = fabs(theta), d_2 = fabs(*dx), d_1 = max(d_2,d_1), d_2 = fabs(*dp);
	s = max(d_2,d_1);
/*        The case gamma = 0 only arises if the cubic does not tend */

/*        to infinity in the direction of the step. */
/* Computing MAX */
/* Computing 2nd power */
	d_3 = theta / s;
	d_1 = 0., d_2 = d_3 * d_3 - *dx / s * (*dp / s);
	gamma = s * sqrt((max(d_2,d_1)));
	if (*stp > *stx) {
	    gamma = -gamma;
	}
	p = gamma - *dp + theta;
	q = gamma + (*dx - *dp) + gamma;
	r = p / q;
	if (r < 0. && gamma != 0.) {
	    stpc = *stp + r * (*stx - *stp);
	} else if (*stp > *stx) {
	    stpc = *stpmax;
	} else {
	    stpc = *stpmin;
	}
	stpq = *stp + *dp / (*dp - *dx) * (*stx - *stp);
	if (*brackt) {
/*           A minimizer has been bracketed. If the cubic step is 
*/
/*           closer to stp than the secant step, the cubic step 
is */
/*           taken, otherwise the secant step is taken. */
	    if ((d_1 = stpc - *stp, fabs(d_1)) < (d_2 = stpq - *stp, fabs(d_2)))
		     {
		stpf = stpc;
	    } else {
		stpf = stpq;
	    }
	    if (*stp > *stx) {
/* Computing MAX */
		d_1 = *stp + (*sty - *stp) * .66;
		stpf = min(stpf,d_1);
	    } else {
/* Computing MAX */
		d_1 = *stp + (*sty - *stp) * .66;
		stpf = max(stpf,d_1);
	    }
	} else {
/*           A minimizer has not been bracketed. If the cubic 
step is */
/*           farther from stp than the secant step, the cubic 
step is */
/*           taken, otherwise the secant step is taken. */
	    if ((d_1 = stpc - *stp, fabs(d_1)) > (d_2 = stpq - *stp, fabs(d_2)))
		     {
		stpf = stpc;
	    } else {
		stpf = stpq;
	    }
	    stpf = min(*stpmax,stpf);
	    stpf = max(*stpmin,stpf);
	}
/*     Fourth case: A lower function value, derivatives of the */
/*     same sign, and the magnitude of the derivative does not */
/*     decrease. If the minimum is not bracketed, the step is either 
*/
/*     stpmin or stpmax, otherwise the cubic step is taken. */
    } else {
	if (*brackt) {
	    theta = (*fp - *fy) * 3. / (*sty - *stp) + *dy + *dp;
/* Computing MAX */
	    d_1 = fabs(theta), d_2 = fabs(*dy), d_1 = max(d_2,d_1), d_2 = fabs(*
		    dp);
	    s = max(d_2,d_1);
/* Computing 2nd power */
	    d_1 = theta / s;
	    gamma = s * sqrt(d_1 * d_1 - *dy / s * (*dp / s));
	    if (*stp > *sty) {
		gamma = -gamma;
	    }
	    p = gamma - *dp + theta;
	    q = gamma - *dp + gamma + *dy;
	    r = p / q;
	    stpc = *stp + r * (*sty - *stp);
	    stpf = stpc;
	} else if (*stp > *stx) {
	    stpf = *stpmax;
	} else {
	    stpf = *stpmin;
	}
    }
/*     Update the interval which contains a minimizer. */
    if (*fp > *fx) {
	*sty = *stp;
	*fy = *fp;
	*dy = *dp;
    } else {
	if (sgnd < 0.) {
	    *sty = *stx;
	    *fy = *fx;
	    *dy = *dx;
	}
	*stx = *stp;
	*fx = *fp;
	*dx = *dp;
    }
/*     Compute the new step. */
    *stp = stpf;
    return 0;
} /* dcstep_ */

/* ====================== The end of dcstep ============================== */
/* Subroutine */ int timer_(double *ttime)
{
/*     ********* */

/*     Subroutine timer */

/*     This subroutine is used to determine user time. In a typical */
/*     application, the user time for a code segment requires calls */
/*     to subroutine timer to determine the initial and final time. */

/*     The subroutine statement is */

/*       subroutine timer(ttime) */

/*     where */

/*       ttime is an output variable which specifies the user time. */

/*     Argonne National Laboratory and University of Minnesota. */
/*     MINPACK-2 Project. */

/*     Modified October 1990 by Brett M. Averick. */

/*     ********** */
/*     The first element of the array tarray specifies user time */
    *ttime= (1.0/(double)CLOCKS_PER_SEC)*clock();
    
    return 0;
} /* timer_ */

/* ====================== The end of timer =============================== */
double dnrm2_(int *n, double *x, int *incx)
{
    /* System generated locals */
    int i_1, i_2;
    double ret_val, d_1, d_2, d_3;

    /* Builtin functions */
    double sqrt(double);

    /* Local variables */
    int i;
    double scale;

    /* Parameter adjustments */
    --x;

    /* Function Body */
/*     ********** */

/*     Function dnrm2 */

/*     Given a vector x of length n, this function calculates the */
/*     Euclidean norm of x with stride incx. */

/*     The function statement is */

/*       double precision function dnrm2(n,x,incx) */

/*     where */

/*       n is a positive int input variable. */

/*       x is an input array of length n. */

/*       incx is a positive int variable that specifies the */
/*         stride of the vector. */

/*     Subprograms called */

/*       FORTRAN-supplied ... abs, max, sqrt */

/*     MINPACK-2 Project. February 1991. */
/*     Argonne National Laboratory. */
/*     Brett M. Averick. */

/*     ********** */
    ret_val = 0.;
    scale = 0.;
    i_1 = *n;
    i_2 = *incx;
    for (i = 1; i_2 < 0 ? i >= i_1 : i <= i_1; i += i_2) {
/* Computing MAX */
	d_2 = scale, d_3 = (d_1 = x[i], fabs(d_1));
	scale = max(d_3,d_2);
/* L10: */
    }
    if (scale == 0.) {
	return ret_val;
    }
    i_2 = *n;
    i_1 = *incx;
    for (i = 1; i_1 < 0 ? i >= i_2 : i <= i_2; i += i_1) {
/* Computing 2nd power */
	d_1 = x[i] / scale;
	ret_val += d_1 * d_1;
/* L20: */
    }
    ret_val = scale * sqrt(ret_val);
    return ret_val;
} /* dnrm2_ */

/* ====================== The end of dnrm2 =============================== */
double dpmeps_(void)
{
    /* Initialized data */

    static double zero = 0.;
    static double one = 1.;
    static double two = 2.;

    /* System generated locals */
    int i_1;
    double ret_val;

    /* Local variables */
    double beta;
    int irnd;
    double temp, temp1, a, b;
    int i;
    double betah;
    int ibeta, negep;
    double tempa;
    int itemp, it;
    double betain;

/*     ********** */

/*     Subroutine dpeps */

/*     This subroutine computes the machine precision parameter */
/*     dpmeps as the smallest floating point number such that */
/*     1 + dpmeps differs from 1. */

/*     This subroutine is based on the subroutine machar described in */

/*     W. J. Cody, */
/*     MACHAR: A subroutine to dynamically determine machine parameters, 
*/
/*     ACM Trans. Math. Soft., 14, 1988, pages 303-311. */

/*     The subroutine statement is: */

/*       subroutine dpeps(dpmeps) */

/*     where */

/*       dpmeps is a double precision variable. */
/*         On entry dpmeps need not be specified. */
/*         On exit dpmeps is the machine precision. */

/*     MINPACK-2 Project. February 1991. */
/*     Argonne National Laboratory and University of Minnesota. */
/*     Brett M. Averick. */

/*     ******* */
/*     determine ibeta, beta ala malcolm. */
    a = one;
    b = one;
L10:
    a += a;
    temp = a + one;
    temp1 = temp - a;
    if (temp1 - one == zero) {
	goto L10;
    }
L20:
    b += b;
    temp = a + b;
    itemp = (int) (temp - a);
    if (itemp == 0) {
	goto L20;
    }
    ibeta = itemp;
    beta = (double) ibeta;
/*     determine it, irnd. */
    it = 0;
    b = one;
L30:
    ++it;
    b *= beta;
    temp = b + one;
    temp1 = temp - b;
    if (temp1 - one == zero) {
	goto L30;
    }
    irnd = 0;
    betah = beta / two;
    temp = a + betah;
    if (temp - a != zero) {
	irnd = 1;
    }
    tempa = a + beta;
    temp = tempa + betah;
    if (irnd == 0 && temp - tempa != zero) {
	irnd = 2;
    }
/*     determine dpmeps. */
    negep = it + 3;
    betain = one / beta;
    a = one;
    i_1 = negep;
    for (i = 1; i <= i_1; ++i) {
	a *= betain;
/* L40: */
    }
L50:
    temp = one + a;
    if (temp - one != zero) {
	goto L60;
    }
    a *= beta;
    goto L50;
L60:
    ret_val = a;
    if (ibeta == 2 || irnd == 0) {
	goto L70;
    }
    a = a * (one + a) / two;
    temp = one + a;
    if (temp - one != zero) {
	ret_val = a;
    }
L70:
    return ret_val;
} /* dpmeps_ */

/* ====================== The end of dpmeps ============================== */
/* Subroutine */ int daxpy_(int *n, double *da, double *dx, 
	int *incx, double *dy, int *incy)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int i, m, ix, iy, mp1;

    /* Parameter adjustments */
    --dx;
    --dy;

    /* Function Body */

/*     constant times a vector plus a vector. */
/*     uses unrolled loops for increments equal to one. */
/*     jack dongarra, linpack, 3/11/78. */


    if (*n <= 0) {
	return 0;
    }
    if (*da == 0.) {
	return 0;
    }
    if (*incx == 1 && *incy == 1) {
	goto L20;
    }

/*        code for unequal increments or equal increments */
/*          not equal to 1 */

    ix = 1;
    iy = 1;
    if (*incx < 0) {
	ix = (-(*n) + 1) * *incx + 1;
    }
    if (*incy < 0) {
	iy = (-(*n) + 1) * *incy + 1;
    }
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	dy[iy] += *da * dx[ix];
	ix += *incx;
	iy += *incy;
/* L10: */
    }
    return 0;

/*        code for both increments equal to 1 */


/*        clean-up loop */

L20:
    m = *n % 4;
    if (m == 0) {
	goto L40;
    }
    i_1 = m;
    for (i = 1; i <= i_1; ++i) {
	dy[i] += *da * dx[i];
/* L30: */
    }
    if (*n < 4) {
	return 0;
    }
L40:
    mp1 = m + 1;
    i_1 = *n;
    for (i = mp1; i <= i_1; i += 4) {
	dy[i] += *da * dx[i];
	dy[i + 1] += *da * dx[i + 1];
	dy[i + 2] += *da * dx[i + 2];
	dy[i + 3] += *da * dx[i + 3];
/* L50: */
    }
    return 0;
} /* daxpy_ */

/* ====================== The end of daxpy =============================== */
/* Subroutine */ int dcopy_(int *n, double *dx, int *incx, 
	double *dy, int *incy)
{
    /* System generated locals */
    int i_1;

    /* Local variables */
    int i, m, ix, iy, mp1;

    /* Parameter adjustments */
    --dx;
    --dy;

    /* Function Body */

/*     copies a vector, x, to a vector, y. */
/*     uses unrolled loops for increments equal to one. */
/*     jack dongarra, linpack, 3/11/78. */


    if (*n <= 0) {
	return 0;
    }
    if (*incx == 1 && *incy == 1) {
	goto L20;
    }

/*        code for unequal increments or equal increments */
/*          not equal to 1 */

    ix = 1;
    iy = 1;
    if (*incx < 0) {
	ix = (-(*n) + 1) * *incx + 1;
    }
    if (*incy < 0) {
	iy = (-(*n) + 1) * *incy + 1;
    }
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	dy[iy] = dx[ix];
	ix += *incx;
	iy += *incy;
/* L10: */
    }
    return 0;

/*        code for both increments equal to 1 */


/*        clean-up loop */

L20:
    m = *n % 7;
    if (m == 0) {
	goto L40;
    }
    i_1 = m;
    for (i = 1; i <= i_1; ++i) {
	dy[i] = dx[i];
/* L30: */
    }
    if (*n < 7) {
	return 0;
    }
L40:
    mp1 = m + 1;
    i_1 = *n;
    for (i = mp1; i <= i_1; i += 7) {
	dy[i] = dx[i];
	dy[i + 1] = dx[i + 1];
	dy[i + 2] = dx[i + 2];
	dy[i + 3] = dx[i + 3];
	dy[i + 4] = dx[i + 4];
	dy[i + 5] = dx[i + 5];
	dy[i + 6] = dx[i + 6];
/* L50: */
    }
    return 0;
} /* dcopy_ */

/* ====================== The end of dcopy =============================== */
double ddot_(int *n, double *dx, int *incx, double *dy, 
	int *incy)
{
    /* System generated locals */
    int i_1;
    double ret_val;

    /* Local variables */
    int i, m;
    double dtemp;
    int ix, iy, mp1;

    /* Parameter adjustments */
    --dx;
    --dy;

    /* Function Body */

/*     forms the dot product of two vectors. */
/*     uses unrolled loops for increments equal to one. */
/*     jack dongarra, linpack, 3/11/78. */


    ret_val = 0.;
    dtemp = 0.;
    if (*n <= 0) {
	return ret_val;
    }
    if (*incx == 1 && *incy == 1) {
	goto L20;
    }

/*        code for unequal increments or equal increments */
/*          not equal to 1 */

    ix = 1;
    iy = 1;
    if (*incx < 0) {
	ix = (-(*n) + 1) * *incx + 1;
    }
    if (*incy < 0) {
	iy = (-(*n) + 1) * *incy + 1;
    }
    i_1 = *n;
    for (i = 1; i <= i_1; ++i) {
	dtemp += dx[ix] * dy[iy];
	ix += *incx;
	iy += *incy;
/* L10: */
    }
    ret_val = dtemp;
    return ret_val;

/*        code for both increments equal to 1 */


/*        clean-up loop */

L20:
    m = *n % 5;
    if (m == 0) {
	goto L40;
    }
    i_1 = m;
    for (i = 1; i <= i_1; ++i) {
	dtemp += dx[i] * dy[i];
/* L30: */
    }
    if (*n < 5) {
	goto L60;
    }
L40:
    mp1 = m + 1;
    i_1 = *n;
    for (i = mp1; i <= i_1; i += 5) {
	dtemp = dtemp + dx[i] * dy[i] + dx[i + 1] * dy[i + 1] + dx[i + 2] * 
		dy[i + 2] + dx[i + 3] * dy[i + 3] + dx[i + 4] * dy[i + 4];
/* L50: */
    }
L60:
    ret_val = dtemp;
    return ret_val;
} /* ddot_ */

/* ====================== The end of ddot ================================ */
/* Subroutine */ int dpofa_(double *a, int *lda, int *n, int *
	info)
{
    /* System generated locals */
    int a_dim1, a_offset, i_1, i_2, i_3;

    /* Builtin functions */
    double sqrt(double);

    /* Local variables */
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    int j, k;
    double s, t;
    int jm1;

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */

/*     dpofa factors a double precision symmetric positive definite */
/*     matrix. */

/*     dpofa is usually called by dpoco, but it can be called */
/*     directly with a saving in time if  rcond  is not needed. */
/*     (time for dpoco) = (1 + 18/n)*(time for dpofa) . */

/*     on entry */

/*        a       double precision(lda, n) */
/*                the symmetric matrix to be factored.  only the */
/*                diagonal and upper triangle are used. */

/*        lda     int */
/*                the leading dimension of the array  a . */

/*        n       int */
/*                the order of the matrix  a . */

/*     on return */

/*        a       an upper triangular matrix  r  so that  a = trans(r)*r 
*/
/*                where  trans(r)  is the transpose. */
/*                the strict lower triangle is unaltered. */
/*                if  info .ne. 0 , the factorization is not complete. */

/*        info    int */
/*                = 0  for normal return. */
/*                = k  signals an error condition.  the leading minor */
/*                     of order  k  is not positive definite. */

/*     linpack.  this version dated 08/14/78 . */
/*     cleve moler, university of new mexico, argonne national lab. */

/*     subroutines and functions */

/*     blas ddot */
/*     fortran sqrt */

/*     internal variables */

/*     begin block with ...exits to 40 */


    i_1 = *n;
    for (j = 1; j <= i_1; ++j) {
	*info = j;
	s = 0.;
	jm1 = j - 1;
	if (jm1 < 1) {
	    goto L20;
	}
	i_2 = jm1;
	for (k = 1; k <= i_2; ++k) {
	    i_3 = k - 1;
	    t = a[k + j * a_dim1] - ddot_(&i_3, &a[k * a_dim1 + 1], &c__1, &a[
		    j * a_dim1 + 1], &c__1);
	    t /= a[k + k * a_dim1];
	    a[k + j * a_dim1] = t;
	    s += t * t;
/* L10: */
	}
L20:
	s = a[j + j * a_dim1] - s;
/*     ......exit */
	if (s <= 0.) {
	    goto L40;
	}
	a[j + j * a_dim1] = sqrt(s);
/* L30: */
    }
    *info = 0;
L40:
    return 0;
} /* dpofa_ */

/* ====================== The end of dpofa =============================== */
/* Subroutine */ int dscal_(int *n, double *da, double *dx, 
	int *incx)
{
    /* System generated locals */
    int i_1, i_2;

    /* Local variables */
    int i, m, nincx, mp1;

    /* Parameter adjustments */
    --dx;

    /* Function Body */

/*     scales a vector by a constant. */
/*     uses unrolled loops for increment equal to one. */
/*     jack dongarra, linpack, 3/11/78. */
/*     modified 3/93 to return if incx .le. 0. */


    if (*n <= 0 || *incx <= 0) {
	return 0;
    }
    if (*incx == 1) {
	goto L20;
    }

/*        code for increment not equal to 1 */

    nincx = *n * *incx;
    i_1 = nincx;
    i_2 = *incx;
    for (i = 1; i_2 < 0 ? i >= i_1 : i <= i_1; i += i_2) {
	dx[i] = *da * dx[i];
/* L10: */
    }
    return 0;

/*        code for increment equal to 1 */


/*        clean-up loop */

L20:
    m = *n % 5;
    if (m == 0) {
	goto L40;
    }
    i_2 = m;
    for (i = 1; i <= i_2; ++i) {
	dx[i] = *da * dx[i];
/* L30: */
    }
    if (*n < 5) {
	return 0;
    }
L40:
    mp1 = m + 1;
    i_2 = *n;
    for (i = mp1; i <= i_2; i += 5) {
	dx[i] = *da * dx[i];
	dx[i + 1] = *da * dx[i + 1];
	dx[i + 2] = *da * dx[i + 2];
	dx[i + 3] = *da * dx[i + 3];
	dx[i + 4] = *da * dx[i + 4];
/* L50: */
    }
    return 0;
} /* dscal_ */

/* ====================== The end of dscal =============================== */
/* Subroutine */ int dtrsl_(double *t, int *ldt, int *n, 
	double *b, int *job, int *info)
{
    /* System generated locals */
    int t_dim1, t_offset, i_1, i_2;

    /* Local variables */
    int case_;
    extern double ddot_(int *, double *, int *, double *, 
	    int *);
    double temp;
    int j;
    extern /* Subroutine */ int daxpy_(int *, double *, double *, 
	    int *, double *, int *);
    int jj;

    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = t_dim1 + 1;
    t -= t_offset;
    --b;

    /* Function Body */


/*     dtrsl solves systems of the form */

/*                   t * x = b */
/*     or */
/*                   trans(t) * x = b */

/*     where t is a triangular matrix of order n. here trans(t) */
/*     denotes the transpose of the matrix t. */

/*     on entry */

/*         t         double precision(ldt,n) */
/*                   t contains the matrix of the system. the zero */
/*                   elements of the matrix are not referenced, and */
/*                   the corresponding elements of the array can be */
/*                   used to store other information. */

/*         ldt       int */
/*                   ldt is the leading dimension of the array t. */

/*         n         int */
/*                   n is the order of the system. */

/*         b         double precision(n). */
/*                   b contains the right hand side of the system. */

/*         job       int */
/*                   job specifies what kind of system is to be solved. */

/*                   if job is */

/*                        00   solve t*x=b, t lower triangular, */
/*                        01   solve t*x=b, t upper triangular, */
/*                        10   solve trans(t)*x=b, t lower triangular, */
/*                        11   solve trans(t)*x=b, t upper triangular. */

/*     on return */

/*         b         b contains the solution, if info .eq. 0. */
/*                   otherwise b is unaltered. */

/*         info      int */
/*                   info contains zero if the system is nonsingular. */
/*                   otherwise info contains the index of */
/*                   the first zero diagonal element of t. */

/*     linpack. this version dated 08/14/78 . */
/*     g. w. stewart, university of maryland, argonne national lab. */

/*     subroutines and functions */

/*     blas daxpy,ddot */
/*     fortran mod */

/*     internal variables */


/*     begin block permitting ...exits to 150 */

/*        check for zero diagonal elements. */

    i_1 = *n;
    for (*info = 1; *info <= i_1; ++(*info)) {
/*     ......exit */
	if (t[*info + *info * t_dim1] == 0.) {
	    goto L150;
	}
/* L10: */
    }
    *info = 0;

/*        determine the task and go to it. */

    case_ = 1;
    if (*job % 10 != 0) {
	case_ = 2;
    }
    if (*job % 100 / 10 != 0) {
	case_ += 2;
    }
    switch (case_) {
	case 1:  goto L20;
	case 2:  goto L50;
	case 3:  goto L80;
	case 4:  goto L110;
    }

/*        solve t*x=b for t lower triangular */

L20:
    b[1] /= t[t_dim1 + 1];
    if (*n < 2) {
	goto L40;
    }
    i_1 = *n;
    for (j = 2; j <= i_1; ++j) {
	temp = -b[j - 1];
	i_2 = *n - j + 1;
	daxpy_(&i_2, &temp, &t[j + (j - 1) * t_dim1], &c__1, &b[j], &c__1);
	b[j] /= t[j + j * t_dim1];
/* L30: */
    }
L40:
    goto L140;

/*        solve t*x=b for t upper triangular. */

L50:
    b[*n] /= t[*n + *n * t_dim1];
    if (*n < 2) {
	goto L70;
    }
    i_1 = *n;
    for (jj = 2; jj <= i_1; ++jj) {
	j = *n - jj + 1;
	temp = -b[j + 1];
	daxpy_(&j, &temp, &t[(j + 1) * t_dim1 + 1], &c__1, &b[1], &c__1);
	b[j] /= t[j + j * t_dim1];
/* L60: */
    }
L70:
    goto L140;

/*        solve trans(t)*x=b for t lower triangular. */

L80:
    b[*n] /= t[*n + *n * t_dim1];
    if (*n < 2) {
	goto L100;
    }
    i_1 = *n;
    for (jj = 2; jj <= i_1; ++jj) {
	j = *n - jj + 1;
	i_2 = jj - 1;
	b[j] -= ddot_(&i_2, &t[j + 1 + j * t_dim1], &c__1, &b[j + 1], &c__1);
	b[j] /= t[j + j * t_dim1];
/* L90: */
    }
L100:
    goto L140;

/*        solve trans(t)*x=b for t upper triangular. */

L110:
    b[1] /= t[t_dim1 + 1];
    if (*n < 2) {
	goto L130;
    }
    i_1 = *n;
    for (j = 2; j <= i_1; ++j) {
	i_2 = j - 1;
	b[j] -= ddot_(&i_2, &t[j * t_dim1 + 1], &c__1, &b[1], &c__1);
	b[j] /= t[j + j * t_dim1];
/* L120: */
    }
L130:
L140:
L150:
    return 0;
} /* dtrsl_ */

