/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.20
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#include "Python.h"

/*************************************************************** -*- c -*-
 * python/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Python_TypeRegister
#define SWIG_TypeCheck       SWIG_Python_TypeCheck
#define SWIG_TypeCast        SWIG_Python_TypeCast
#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
#define SWIG_TypeName        SWIG_Python_TypeName
#define SWIG_TypeQuery       SWIG_Python_TypeQuery
#define SWIG_TypeClientData  SWIG_Python_TypeClientData
#define SWIG_PackData        SWIG_Python_PackData 
#define SWIG_UnpackData      SWIG_Python_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti) {
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
  l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty) {
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
        s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) {
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
        if ((strcmp(tc->name, equiv->name) == 0))
          SWIG_TypeClientData(tc,clientdata);
        tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

#endif

#ifdef __cplusplus
}
#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

/* Common SWIG API */
#define SWIG_ConvertPtr(obj, pp, type, flags) \
  SWIG_Python_ConvertPtr(obj, pp, type, flags)
#define SWIG_NewPointerObj(p, type, flags) \
  SWIG_Python_NewPointerObj(p, type, flags)
#define SWIG_MustGetPtr(p, type, argnum, flags) \
  SWIG_Python_MustGetPtr(p, type, argnum, flags)

/* Python-specific SWIG API */
#define SWIG_newvarlink() \
  SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr) \
  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type) \
  SWIG_Python_NewPackedObj(ptr, sz, type)
#define SWIG_InstallConstants(d, constants) \
  SWIG_Python_InstallConstants(d, constants)

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",              /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
    PyObject *zero = PyInt_FromLong(0);
    PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
    Py_DECREF(zero);
  }
  return 0;

type_error:
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME(void *)
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
  return result;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c = 0;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty && c) {
      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
        PyObject *n = PyInt_FromLong(1);
        PyObject_SetAttrString(inst,(char*)"thisown",n);
        Py_DECREF(n);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

/* Contract support */

#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Transform swig_types[0] 
#define  SWIGTYPE_p_double swig_types[1] 
#define  SWIGTYPE_p_SFUNVALUEFUNC swig_types[2] 
#define  SWIGTYPE_p_SFUNRESETFUNC swig_types[3] 
#define  SWIGTYPE_p_KalmanState swig_types[4] 
#define  SWIGTYPE_p_ScalarFunction swig_types[5] 
#define  SWIGTYPE_p_SplineType swig_types[6] 
#define  SWIGTYPE_p_Interpolator swig_types[7] 
#define  SWIGTYPE_p_Optimizer swig_types[8] 
#define  SWIGTYPE_p_FILE swig_types[9] 
#define  SWIGTYPE_p_long swig_types[10] 
#define  SWIGTYPE_p_KalmanProcess swig_types[11] 
#define  SWIGTYPE_p_Regressor swig_types[12] 
#define  SWIGTYPE_p_KalmanFilter swig_types[13] 
static swig_type_info *swig_types[15];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _fiasco_numpy.so
  ------------------------------------------------*/
#define SWIG_init    init_fiasco_numpy

#define SWIG_name    "_fiasco_numpy"

#define SWIG_FILE_WITH_INIT
#include "glm.h"
#include "optimizer.h"
#include "quaternion.h"
#include "interpolator.h"
#include "kalmanfilter.h"


#ifndef SWIG_FILE_WITH_INIT
#  define NO_IMPORT_ARRAY
#endif
#include "stdio.h"
#include <numpy/arrayobject.h>

/* The following code originally appeared in
 * enthought/kiva/agg/src/numeric.i written by Eric Jones.  It was
 * translated from C++ to C by John Hunter.  Bill Spotz has modified
 * it slightly to fix some minor bugs, upgrade to numpy (all
 * versions), add some comments and some functionality.
 */

/* Macros to extract array attributes.
 */
#define is_array(a)            ((a) && PyArray_Check((PyArrayObject *)a))
#define array_type(a)          (int)(PyArray_TYPE(a))
#define array_numdims(a)       (((PyArrayObject *)a)->nd)
#define array_dimensions(a)    (((PyArrayObject *)a)->dimensions)
#define array_size(a,i)        (((PyArrayObject *)a)->dimensions[i])
#define array_data(a)          (((PyArrayObject *)a)->data)
#define array_is_contiguous(a) (PyArray_ISCONTIGUOUS(a))
#define array_is_native(a)     (PyArray_ISNOTSWAPPED(a))

/* Support older NumPy data type names
*/
#if NDARRAY_VERSION < 0x01000000
#define NPY_BOOL        PyArray_BOOL
#define NPY_BYTE        PyArray_BYTE
#define NPY_UBYTE       PyArray_UBYTE
#define NPY_SHORT       PyArray_SHORT
#define NPY_USHORT      PyArray_USHORT
#define NPY_INT         PyArray_INT
#define NPY_UINT        PyArray_UINT
#define NPY_LONG        PyArray_LONG
#define NPY_ULONG       PyArray_ULONG
#define NPY_LONGLONG    PyArray_LONGLONG
#define NPY_ULONGLONG   PyArray_ULONGLONG
#define NPY_FLOAT       PyArray_FLOAT
#define NPY_DOUBLE      PyArray_DOUBLE
#define NPY_LONGDOUBLE  PyArray_LONGDOUBLE
#define NPY_CFLOAT      PyArray_CFLOAT
#define NPY_CDOUBLE     PyArray_CDOUBLE
#define NPY_CLONGDOUBLE PyArray_CLONGDOUBLE
#define NPY_OBJECT      PyArray_OBJECT
#define NPY_STRING      PyArray_STRING
#define NPY_UNICODE     PyArray_UNICODE
#define NPY_VOID        PyArray_VOID
#define NPY_NTYPES      PyArray_NTYPES
#define NPY_NOTYPE      PyArray_NOTYPE
#define NPY_CHAR        PyArray_CHAR
#define NPY_USERDEF     PyArray_USERDEF
#define npy_intp        intp
#endif

/* Given a PyObject, return a string describing its type.
 */
char* pytype_string(PyObject* py_obj) {
  if (py_obj == NULL          ) return "C NULL value";
  if (py_obj == Py_None       ) return "Python None" ;
  if (PyCallable_Check(py_obj)) return "callable"    ;
  if (PyString_Check(  py_obj)) return "string"      ;
  if (PyInt_Check(     py_obj)) return "int"         ;
  if (PyFloat_Check(   py_obj)) return "float"       ;
  if (PyDict_Check(    py_obj)) return "dict"        ;
  if (PyList_Check(    py_obj)) return "list"        ;
  if (PyTuple_Check(   py_obj)) return "tuple"       ;
  if (PyFile_Check(    py_obj)) return "file"        ;
  if (PyModule_Check(  py_obj)) return "module"      ;
  if (PyInstance_Check(py_obj)) return "instance"    ;

  return "unkown type";
}

/* Given a NumPy typecode, return a string describing the type.
 */
char* typecode_string(int typecode) {
  static char* type_names[25] = {"bool", "byte", "unsigned byte",
				 "short", "unsigned short", "int",
				 "unsigned int", "long", "unsigned long",
				 "long long", "unsigned long long",
				 "float", "double", "long double",
				 "complex float", "complex double",
				 "complex long double", "object",
				 "string", "unicode", "void", "ntypes",
				 "notype", "char", "unknown"};
  return typecode < 24 ? type_names[typecode] : type_names[24];
}

/* Make sure input has correct numpy type.  Allow character and byte
 * to match.  Also allow int and long to match.  This is deprecated.
 * You should use PyArray_EquivTypenums() instead.
 */
int type_match(int actual_type, int desired_type) {
  return PyArray_EquivTypenums(actual_type, desired_type);
}

/* Given a PyObject pointer, cast it to a PyArrayObject pointer if
 * legal.  If not, set the python error string appropriately and
 * return NULL.
 */
PyArrayObject* obj_to_array_no_conversion(PyObject* input, int typecode) {
  PyArrayObject* ary = NULL;
  if (is_array(input) && (typecode == NPY_NOTYPE ||
			  PyArray_EquivTypenums(array_type(input), typecode))) {
    ary = (PyArrayObject*) input;
  }
  else if is_array(input) {
    char* desired_type = typecode_string(typecode);
    char* actual_type  = typecode_string(array_type(input));
    PyErr_Format(PyExc_TypeError, 
		 "Array of type '%s' required.  Array of type '%s' given", 
		 desired_type, actual_type);
    ary = NULL;
  }
  else {
    char * desired_type = typecode_string(typecode);
    char * actual_type  = pytype_string(input);
    PyErr_Format(PyExc_TypeError, 
		 "Array of type '%s' required.  A '%s' was given", 
		 desired_type, actual_type);
    ary = NULL;
  }
  return ary;
}

/* Convert the given PyObject to a NumPy array with the given
 * typecode.  On success, return a valid PyArrayObject* with the
 * correct type.  On failure, the python error string will be set and
 * the routine returns NULL.
 */
PyArrayObject* obj_to_array_allow_conversion(PyObject* input, int typecode,
                                             int* is_new_object) {
  PyArrayObject* ary = NULL;
  PyObject* py_obj;
  if (is_array(input) && (typecode == NPY_NOTYPE ||
			  PyArray_EquivTypenums(array_type(input),typecode))) {
    ary = (PyArrayObject*) input;
    *is_new_object = 0;
  }
  else {
    py_obj = PyArray_FromObject(input, typecode, 0, 0);
    /* If NULL, PyArray_FromObject will have set python error value.*/
    ary = (PyArrayObject*) py_obj;
    *is_new_object = 1;
  }
  return ary;
}

/* Given a PyArrayObject, check to see if it is contiguous.  If so,
 * return the input pointer and flag it as not a new object.  If it is
 * not contiguous, create a new PyArrayObject using the original data,
 * flag it as a new object and return the pointer.
 */
PyArrayObject* make_contiguous(PyArrayObject* ary, int* is_new_object,
                               int min_dims, int max_dims) {
  PyArrayObject* result;
  if (array_is_contiguous(ary)) {
    result = ary;
    *is_new_object = 0;
  }
  else {
    result = (PyArrayObject*) PyArray_ContiguousFromObject((PyObject*)ary, 
							   array_type(ary), 
							   min_dims,
							   max_dims);
    *is_new_object = 1;
  }
  return result;
}

/* Convert a given PyObject to a contiguous PyArrayObject of the
 * specified type.  If the input object is not a contiguous
 * PyArrayObject, a new one will be created and the new object flag
 * will be set.
 */
PyArrayObject* obj_to_array_contiguous_allow_conversion(PyObject* input,
                                                        int typecode,
                                                        int* is_new_object) {
  int is_new1 = 0;
  int is_new2 = 0;
  PyArrayObject* ary2;
  PyArrayObject* ary1 = obj_to_array_allow_conversion(input, typecode, 
						      &is_new1);
  if (ary1) {
    ary2 = make_contiguous(ary1, &is_new2, 0, 0);
    if ( is_new1 && is_new2) {
      Py_DECREF(ary1);
    }
    ary1 = ary2;    
  }
  *is_new_object = is_new1 || is_new2;
  return ary1;
}

/* Test whether a python object is contiguous.  If array is
 * contiguous, return 1.  Otherwise, set the python error string and
 * return 0.
 */
int require_contiguous(PyArrayObject* ary) {
  int contiguous = 1;
  if (!array_is_contiguous(ary)) {
    PyErr_SetString(PyExc_TypeError,
		    "Array must be contiguous.  A non-contiguous array was given");
    contiguous = 0;
  }
  return contiguous;
}

/* Require that a numpy array is not byte-swapped.  If the array is
 * not byte-swapped, return 1.  Otherwise, set the python error string
 * and return 0.
 */
int require_native(PyArrayObject* ary) {
  int native = 1;
  if (!array_is_native(ary)) {
    PyErr_SetString(PyExc_TypeError,
		    "Array must have native byteorder.  A byte-swapped array was given");
    native = 0;
  }
  return native;
}

/* Require the given PyArrayObject to have a specified number of
 * dimensions.  If the array has the specified number of dimensions,
 * return 1.  Otherwise, set the python error string and return 0.
 */
int require_dimensions(PyArrayObject* ary, int exact_dimensions) {
  int success = 1;
  if (array_numdims(ary) != exact_dimensions) {
    PyErr_Format(PyExc_TypeError, 
		 "Array must have %d dimensions.  Given array has %d dimensions", 
		 exact_dimensions, array_numdims(ary));
    success = 0;
  }
  return success;
}

/* Require the given PyArrayObject to have one of a list of specified
 * number of dimensions.  If the array has one of the specified number
 * of dimensions, return 1.  Otherwise, set the python error string
 * and return 0.
 */
int require_dimensions_n(PyArrayObject* ary, int* exact_dimensions, int n) {
  int success = 0;
  int i;
  char dims_str[255] = "";
  char s[255];
  for (i = 0; i < n && !success; i++) {
    if (array_numdims(ary) == exact_dimensions[i]) {
      success = 1;
    }
  }
  if (!success) {
    for (i = 0; i < n-1; i++) {
      sprintf(s, "%d, ", exact_dimensions[i]);                
      strcat(dims_str,s);
    }
    sprintf(s, " or %d", exact_dimensions[n-1]);            
    strcat(dims_str,s);
    PyErr_Format(PyExc_TypeError, 
		 "Array must be have %s dimensions.  Given array has %d dimensions",
		 dims_str, array_numdims(ary));
  }
  return success;
}    

/* Require the given PyArrayObject to have a specified shape.  If the
 * array has the specified shape, return 1.  Otherwise, set the python
 * error string and return 0.
 */
int require_size(PyArrayObject* ary, npy_intp* size, int n) {
  int i;
  int success = 1;
  int len;
  char desired_dims[255] = "[";
  char s[255];
  char actual_dims[255] = "[";
  for(i=0; i < n;i++) {
    if (size[i] != -1 &&  size[i] != array_size(ary,i)) {
      success = 0;    
    }
  }
  if (!success) {
    for (i = 0; i < n; i++) {
      if (size[i] == -1) {
	sprintf(s, "*,");                
      }
      else
      {
	sprintf(s, "%d,", size[i]);                
      }    
      strcat(desired_dims,s);
    }
    len = strlen(desired_dims);
    desired_dims[len-1] = ']';
    for (i = 0; i < n; i++) {
      sprintf(s, "%d,", array_size(ary,i));                            
      strcat(actual_dims,s);
    }
    len = strlen(actual_dims);
    actual_dims[len-1] = ']';
    PyErr_Format(PyExc_TypeError, 
		 "Array must be have shape of %s.  Given array has shape of %s",
		 desired_dims, actual_dims);
  }
  return success;
}

/* End John Hunter translation (with modifications by Bill Spotz)
 */


Regressor *new_Regressor(){ return glm_create_llsq_regressor(); }
void delete_Regressor(Regressor *self){ self->destroy_self(self); }
int Regressor_get(Regressor *self,glm_feature f){ return(self->get(self,f)); }
int Regressor_is_settable(Regressor *self,glm_feature f){ return(self->is_settable(self,f)); }
void Regressor_set(Regressor *self,glm_feature f,int val){
      self->set(self,f,val);
      if (glm_error_msg()) {
	PyErr_SetString(PyExc_RuntimeError,glm_error_msg());
      }
    }
int Regressor_n_params(Regressor *self,int nfactors){ return(self->n_params(self,nfactors)); }
int Regressor_context_valid(Regressor *self,int nobs,int nfactors){
      return (self->context_valid(self,nobs,nfactors));
    }

void Regressor_fit(Regressor* r, double* obs, int nobs,
		   const double* factors, int nfactors_1, int nfactors_2,
		   const double* counts, int ncounts,
		   double* param_out, int nparam) {
  if (nfactors_1 != nobs) {
    PyErr_SetString(PyExc_RuntimeError,
		    "factor vector length does not match obs vector");
  }
  if ((counts != NULL) && (ncounts != nobs)) {
    PyErr_SetString(PyExc_RuntimeError,
		    "counts length does not match obs vector");
  }
  if (nparam < r->n_params(r,nfactors_2)) {
    PyErr_SetString(PyExc_RuntimeError,"param_out array is too small");
    return;
  }
  if (r->fit(r, obs, factors, counts, param_out, nobs, nfactors_2)) {
    PyErr_SetString(PyExc_RuntimeError,glm_error_msg());
  }
}


  typedef double (*SFUNVALUEFUNC)(const double* vals, const int n, 
				  void* clientdata);
  typedef void (*SFUNRESETFUNC)(const double* vals, const int n, 
				void* clientdata);

/* This function matches the prototype of the normal C value callback
   function for ScalarFunction. However, we use the clientdata pointer
   for holding a reference to a Python callable object. */
  static double PythonSFunValueFunc(const double* vals, const int n,
				    void *clientdata)
{
    PyObject *valFunc, *resetFunc, *data, *valList, *arglist;
    PyObject *valArray;
    PyObject *resultObj;
    double result;
    int dimensions[1];
    
    // Break data into components
    valFunc= PyTuple_GetItem(clientdata,0);
    resetFunc= PyTuple_GetItem(clientdata,1);
    data= PyTuple_GetItem(clientdata,3);
    
    dimensions[0]= n;
    valArray= PyArray_FromDimsAndData(1,dimensions,PyArray_DOUBLE,(char*)vals);

    arglist = Py_BuildValue("OO",valArray,data);        // Build argument list
    resultObj = PyEval_CallObject(valFunc,arglist);     // Call Python
    Py_DECREF(arglist);                                 // Trash arglist
    if (resultObj) result= PyFloat_AsDouble(resultObj);
    else PyErr_SetString(PyExc_RuntimeError,"Optimizer value function failed");
    Py_XDECREF(resultObj);
    return result;
}

/* This function matches the prototype of the normal C reset callback
   function for ScalarFunction. However, we use the clientdata pointer
   for holding a reference to a Python callable object. */
  static void PythonSFunResetFunc(const double* vals, const int n,
				    void *clientdata)
{
    PyObject *valFunc, *resetFunc, *data, *valList, *arglist;
    PyObject *valArray;
    PyObject *resultObj;
    double result;
    int dimensions[1];
    
    // Break data into components
    valFunc= PyTuple_GetItem(clientdata,0);
    resetFunc= PyTuple_GetItem(clientdata,1);
    data= PyTuple_GetItem(clientdata,3);
    
    dimensions[0]= n;
    valArray= PyArray_FromDimsAndData(1,dimensions,PyArray_DOUBLE,(char*)vals);

    arglist = Py_BuildValue("OO",valArray,data);        // Build argument list
    resultObj = PyEval_CallObject(resetFunc,arglist);     // Call Python
    Py_DECREF(arglist);                                 // Trash arglist
    if (resultObj) Py_XDECREF(resultObj);
    else PyErr_SetString(PyExc_RuntimeError,"Optimizer reset function failed");
}

void delete_ScalarFunction(ScalarFunction *self){ self->destroySelf(self); }
double ScalarFunction_value(ScalarFunction *self,double const *par,int const nPar){
      return self->value(self, par, nPar);
    }
void ScalarFunction_reset(ScalarFunction *self,double const *par,int const nPar){
      self->reset(self, par, nPar);
    }
void delete_Optimizer(Optimizer *self){ self->destroySelf(self); }
char const *Optimizer___str__(Optimizer *self){ return self->getMethodName(self); }
char *Optimizer___repr__(Optimizer *self){ return self->getStringRep(self); }
int Optimizer_getDebugLevel(Optimizer *self){ return self->getDebugLevel(self); }
void Optimizer_setDebugLevel(Optimizer *self,int const lvl){ self->setDebugLevel(self,lvl); }

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

int Optimizer_go(Optimizer *self,ScalarFunction *f,double *par,int const nPar,double *best){ return self->go(self,f,par,nPar,best); }
void delete_Interpolator(Interpolator *self){ self->destroySelf(self); }
char const *Interpolator_getTypeName(Interpolator *self){ return self->typeName; }
void Interpolator_prep(Interpolator *self,double *data,long sz){ 
      self->prep(self, data, sz); 
    }
void Interpolator_calc(Interpolator *self,double *calcResult,double *calcLoc,long runLength,long offset){ 
      self->calc(self, calcResult, calcLoc, runLength, offset); 
    }
void Interpolator_dumpSelf(Interpolator *self,FILE *ofile){ self->dumpSelf(self, ofile); }
void Interpolator_setInt(Interpolator *self,int which,long val){ self->setInt(self, which, val); }
void Interpolator_setDouble(Interpolator *self,int which,double val){ self->setDouble(self,which,val); }
long Interpolator_getInt(Interpolator *self,int which){ return(self->getInt(self,which)); }
double Interpolator_getDouble(Interpolator *self,int which){ return(self->getDouble(self,which)); }
extern InterpolatorType intrp_typeFromName(char const *);
extern char const *intrp_nameFromType(InterpolatorType);
extern void intrp_warpClearCounts(void);
extern void intrp_warpGetCounts(long *);
extern Interpolator *intrp_createClosestInterpolator1D(long,long);
extern Interpolator *intrp_createClosestInterpolator2D(long,long,long);
extern Interpolator *intrp_createClosestInterpolator3D(long,long,long,long);
extern Interpolator *intrp_createLinearInterpolator1D(long,long);
extern Interpolator *intrp_createLinearInterpolator2D(long,long,long);
extern Interpolator *intrp_createLinearInterpolator3D(long,long,long,long);
extern Interpolator *intrp_createSplineInterpolator1D(SplineType,long,long);
extern Interpolator *intrp_createSplineInterpolator2D(SplineType,long,long,long);
extern Interpolator *intrp_createSplineInterpolator3D(SplineType,long,long,long,long);
extern Interpolator *intrp_createInterpolator1DByType(InterpolatorType,long,long);
extern Interpolator *intrp_createInterpolator2DByType(InterpolatorType,long,long,long);
extern Interpolator *intrp_createInterpolator3DByType(InterpolatorType,long,long,long,long);
void delete_KalmanProcess(KalmanProcess *self){ self->destroySelf(self); }
void KalmanProcess_dumpSelf(KalmanProcess *self,FILE *ofile){ self->dumpSelf(self,ofile); }
void KalmanProcess_setDebug(KalmanProcess *self,int val){ self->setDebug(self,val); }
int KalmanProcess_getDebug(KalmanProcess *self){ return self->getDebug(self); }
void KalmanProcess_setA(KalmanProcess *self,double *IN_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1 != self->M || DIM2!= self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->setA(self,IN_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_getA(KalmanProcess *self,double *INPLACE_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1 != self->M || DIM2 != self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->getA(self,INPLACE_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_setH(KalmanProcess *self,double *IN_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1!=self->L || DIM2!=self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->setH(self,IN_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_getH(KalmanProcess *self,double *INPLACE_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1 != self->L || DIM2 != self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->getH(self,INPLACE_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_setQ(KalmanProcess *self,double *IN_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1!=self->M || DIM2!=self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->setQ(self,IN_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_getQ(KalmanProcess *self,double *INPLACE_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1 != self->M || DIM2 != self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->getQ(self,INPLACE_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_setR(KalmanProcess *self,double *IN_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1!=self->L || DIM2!=self->L) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->setR(self,IN_ARRAY2,DIM1*DIM2); 
    }
void KalmanProcess_getR(KalmanProcess *self,double *INPLACE_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1 != self->L || DIM2 != self->L) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->getR(self,INPLACE_ARRAY2,DIM1*DIM2); 
    }
int KalmanProcess_getL(KalmanProcess *self){ return self->L; }
int KalmanProcess_getM(KalmanProcess *self){ return self->M; }
double KalmanProcess_apply(KalmanProcess *self,KalmanState *state,double *IN_ARRAY1,int DIM1,int missing,int calcLogLikelihoodDelta,int updatePandK){ 
      if (DIM1 != self->L) {
	PyErr_SetString(PyExc_RuntimeError,"wrong z vector length");
	return 0.0;
      }
      return( self->apply(self,state,IN_ARRAY1,DIM1,missing,
			  calcLogLikelihoodDelta,
			  updatePandK)); 
    }
void delete_KalmanState(KalmanState *self){ self->destroySelf(self); }
void KalmanState_dumpSelf(KalmanState *self,FILE *ofile){ self->dumpSelf(self,ofile); }
void KalmanState_setX(KalmanState *self,double *INPLACE_ARRAY1,int DIM1){ 
      if (DIM1!=self->M) {
	PyErr_SetString(PyExc_RuntimeError,"wrong x vector length");
	return;
      }
      self->setX(self,INPLACE_ARRAY1,DIM1); 
    }
void KalmanState_setP(KalmanState *self,double *INPLACE_ARRAY2,int DIM1,int DIM2){ 
      if (DIM1!=self->M || DIM2!=self->M) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch");
	return;
      }
      self->setP(self,INPLACE_ARRAY2,DIM1*DIM2); 
    }
int KalmanState_getM(KalmanState *self){ return self->M; }
void delete_KalmanFilter(KalmanFilter *self){ self->destroySelf(self); }
void KalmanFilter_dumpSelf(KalmanFilter *self,FILE *ofile){ self->dumpSelf(self,ofile); }
int KalmanFilter_getL(KalmanFilter *self){ return self->L; }
int KalmanFilter_getM(KalmanFilter *self){ return self->M; }
KalmanState *KalmanFilter_getState(KalmanFilter *self){ return self->state; }
double KalmanFilter_run(KalmanFilter *self,long tdim,double const *zIn,int zDim1,int zDim2,double *xOut,int xDim1,int xDim2,double *POut,int pDim1,int pDim2,int pDim3,int calcLogLikelihood){
      if (zDim2!=self->L || zDim1!=tdim) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch on zIn");
	return 0.0;
      }
      if (xDim2!=self->M || xDim1!=tdim) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch on xOut");
	return 0.0;
      }
      if (pDim3!=self->M || pDim2!=self->M || pDim1!=tdim) {
	PyErr_SetString(PyExc_RuntimeError,"array size mismatch on POut");
	return 0.0;
      }
      return self->run(self, tdim, 
		       zIn, zDim1*zDim2,
		       xOut, xDim1*xDim2,
		       POut, pDim1*pDim2*pDim3,
		       calcLogLikelihood);
    }
extern KalmanProcess *klmn_createRowMajorKalmanProcess(int,int);
extern KalmanState *klmn_createRowMajorKalmanState(int);
extern KalmanFilter *klmn_createKalmanFilter(KalmanProcess *);
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_new_Regressor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Regressor")) goto fail;
    {
        result = (Regressor *)new_Regressor();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Regressor, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Regressor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Regressor",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_Regressor(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Regressor_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    int arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Regressor_get",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)Regressor_get(arg1,(glm_feature )arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Regressor_is_settable(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    int arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Regressor_is_settable",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)Regressor_is_settable(arg1,(glm_feature )arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Regressor_set(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    int arg2 ;
    int arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:Regressor_set",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Regressor_set(arg1,(glm_feature )arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Regressor_n_params(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    int arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Regressor_n_params",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)Regressor_n_params(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Regressor_fit(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    double *arg4 = (double *) 0 ;
    int arg5 ;
    int arg6 ;
    double *arg7 = (double *) 0 ;
    int arg8 ;
    double *arg9 = (double *) 0 ;
    int arg10 ;
    PyArrayObject *array2 = NULL ;
    PyArrayObject *array3 = NULL ;
    int is_new_object3 = 0 ;
    PyArrayObject *array4 = NULL ;
    int is_new_object4 = 0 ;
    PyArrayObject *array5 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:Regressor_fit",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,1) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array2); ++i) arg3 *= array_size(array2,i);
        }
    }
    {
        array3 = obj_to_array_contiguous_allow_conversion(obj2, NPY_DOUBLE, &is_new_object3);
        npy_intp size[2] = {
            -1, -1 
        };
        if (!array3 || !require_dimensions(array3, 2) || !require_size(array3, size, 2)) SWIG_fail;
        arg4 = (double*) array_data(array3);
        arg5 = (int) array_size(array3,0);
        arg6 = (int) array_size(array3,1);
    }
    {
        array4 = obj_to_array_contiguous_allow_conversion(obj3, NPY_DOUBLE, &is_new_object4);
        npy_intp size[1] = {
            -1 
        };
        if (!array4 || !require_dimensions(array4, 1) || !require_size(array4, size, 1)) SWIG_fail;
        arg7 = (double*) array_data(array4);
        arg8 = (int) array_size(array4,0);
    }
    {
        array5 = obj_to_array_no_conversion(obj4, NPY_DOUBLE);
        if (!array5 || !require_dimensions(array5,1) || !require_contiguous(array5)
        || !require_native(array5)) SWIG_fail;
        arg9 = (double*) array_data(array5);
        arg10 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array5); ++i) arg10 *= array_size(array5,i);
        }
    }
    {
        Regressor_fit(arg1,arg2,arg3,(double const *)arg4,arg5,arg6,(double const *)arg7,arg8,arg9,arg10);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        if (is_new_object4 && array4) Py_DECREF(array4);
    }
    {
        if (is_new_object5 && array5) Py_DECREF(array5);
    }
    return resultobj;
    fail:
    {
        if (is_new_object4 && array4) Py_DECREF(array4);
    }
    {
        if (is_new_object5 && array5) Py_DECREF(array5);
    }
    return NULL;
}


static PyObject *_wrap_Regressor_context_valid(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *arg1 = (Regressor *) 0 ;
    int arg2 ;
    int arg3 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:Regressor_context_valid",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Regressor,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)Regressor_context_valid(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Regressor_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Regressor, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_create_base_regressor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *result;
    
    if(!PyArg_ParseTuple(args,(char *)":create_base_regressor")) goto fail;
    {
        result = (Regressor *)glm_create_base_regressor();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Regressor, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_create_llsq_regressor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *result;
    
    if(!PyArg_ParseTuple(args,(char *)":create_llsq_regressor")) goto fail;
    {
        result = (Regressor *)glm_create_llsq_regressor();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Regressor, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_create_logistic_regressor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *result;
    
    if(!PyArg_ParseTuple(args,(char *)":create_logistic_regressor")) goto fail;
    {
        result = (Regressor *)glm_create_logistic_regressor();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Regressor, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_create_poisson_regressor(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Regressor *result;
    
    if(!PyArg_ParseTuple(args,(char *)":create_poisson_regressor")) goto fail;
    {
        result = (Regressor *)glm_create_poisson_regressor();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Regressor, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ScalarFunction(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ScalarFunction *arg1 = (ScalarFunction *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ScalarFunction",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ScalarFunction,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_ScalarFunction(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ScalarFunction_value(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ScalarFunction *arg1 = (ScalarFunction *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    double result;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ScalarFunction_value",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ScalarFunction,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,1) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array2); ++i) arg3 *= array_size(array2,i);
        }
    }
    {
        result = (double)ScalarFunction_value(arg1,(double const *)arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ScalarFunction_reset(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ScalarFunction *arg1 = (ScalarFunction *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ScalarFunction_reset",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ScalarFunction,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,1) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array2); ++i) arg3 *= array_size(array2,i);
        }
    }
    {
        ScalarFunction_reset(arg1,(double const *)arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_ScalarFunction(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ScalarFunction *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_ScalarFunction")) goto fail;
    {
        result = (ScalarFunction *)(ScalarFunction *) calloc(1, sizeof(ScalarFunction));
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ScalarFunction, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ScalarFunction_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ScalarFunction, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_buildSimpleScalarFunction(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SFUNVALUEFUNC arg1 ;
    SFUNRESETFUNC arg2 ;
    int arg3 ;
    void *arg4 = (void *) 0 ;
    ScalarFunction *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:buildSimpleScalarFunction",&obj0)) goto fail;
    {
        if (!PyTuple_Check(obj0)) {
            PyErr_SetString(PyExc_TypeError, "Expected a tuple!");
            return NULL;
        }
        if (PyTuple_Size(obj0)!=4) {
            PyErr_SetString(PyExc_TypeError, "Tuple size is not 4!");
            return NULL;
        }
        if (!PyCallable_Check(PyTuple_GetItem(obj0,0))) {
            PyErr_SetString(PyExc_TypeError, "First tuple element is not a function!");
            return NULL;
        }
        if (!PyCallable_Check(PyTuple_GetItem(obj0,1))) {
            PyErr_SetString(PyExc_TypeError, 
            "Second tuple element is not a function!");
            return NULL;
        }
        if (!PyInt_Check(PyTuple_GetItem(obj0,2))) {
            PyErr_SetString(PyExc_TypeError, 
            "Third tuple element is not an int!");
            return NULL;
        }
        arg3= (int)PyInt_AsLong(PyTuple_GetItem(obj0,2));
        
        Py_INCREF(obj0);
        arg1= PythonSFunValueFunc; arg2= PythonSFunResetFunc; arg4= obj0;
    }
    {
        result = (ScalarFunction *)buildSimpleScalarFunction(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ScalarFunction, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Optimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *arg1 = (Optimizer *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Optimizer",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Optimizer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_Optimizer(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Optimizer___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *arg1 = (Optimizer *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Optimizer___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Optimizer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (char *)Optimizer___str__(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Optimizer___repr__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *arg1 = (Optimizer *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Optimizer___repr__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Optimizer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (char *)Optimizer___repr__(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Optimizer_getDebugLevel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *arg1 = (Optimizer *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Optimizer_getDebugLevel",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Optimizer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)Optimizer_getDebugLevel(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Optimizer_setDebugLevel(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *arg1 = (Optimizer *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Optimizer_setDebugLevel",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Optimizer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Optimizer_setDebugLevel(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Optimizer_go(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *arg1 = (Optimizer *) 0 ;
    ScalarFunction *arg2 = (ScalarFunction *) 0 ;
    double *arg3 = (double *) 0 ;
    int arg4 ;
    double *arg5 = (double *) 0 ;
    int result;
    PyArrayObject *array3 = NULL ;
    double temp4 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    arg5 = &temp4;
    if(!PyArg_ParseTuple(args,(char *)"OOO:Optimizer_go",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Optimizer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ScalarFunction,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array3 = obj_to_array_no_conversion(obj2, NPY_DOUBLE);
        if (!array3 || !require_dimensions(array3,1) || !require_contiguous(array3)
        || !require_native(array3)) SWIG_fail;
        arg3 = (double*) array_data(array3);
        arg4 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array3); ++i) arg4 *= array_size(array3,i);
        }
    }
    {
        result = (int)Optimizer_go(arg1,arg2,arg3,arg4,arg5);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    {
        PyObject *o = PyFloat_FromDouble((double) (*arg5));
        resultobj = t_output_helper(resultobj,o);
    }
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Optimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Optimizer")) goto fail;
    {
        result = (Optimizer *)(Optimizer *) calloc(1, sizeof(Optimizer));
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Optimizer_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Optimizer, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_optimizerFromStringRep(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:optimizerFromStringRep",&arg1)) goto fail;
    {
        result = (Optimizer *)optimizerFromStringRep((char const *)arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createBaseOptimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)":createBaseOptimizer")) goto fail;
    {
        result = (Optimizer *)createBaseOptimizer();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createNoneOptimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)":createNoneOptimizer")) goto fail;
    {
        result = (Optimizer *)createNoneOptimizer();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createPraxisOptimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)"dd:createPraxisOptimizer",&arg1,&arg2)) goto fail;
    {
        result = (Optimizer *)createPraxisOptimizer(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createNelminOptimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    int arg3 ;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ddi:createNelminOptimizer",&arg1,&arg2,&arg3)) goto fail;
    {
        result = (Optimizer *)createNelminOptimizer(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createNelminTOptimizer(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    double arg1 ;
    double arg2 ;
    double arg3 ;
    int arg4 ;
    Optimizer *result;
    
    if(!PyArg_ParseTuple(args,(char *)"dddi:createNelminTOptimizer",&arg1,&arg2,&arg3,&arg4)) goto fail;
    {
        result = (Optimizer *)createNelminTOptimizer(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Optimizer, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_Interpolator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_Interpolator",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_Interpolator(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_getTypeName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:Interpolator_getTypeName",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (char *)Interpolator_getTypeName(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_prep(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    double *arg2 = (double *) 0 ;
    long arg3 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Interpolator_prep",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array2); ++i) arg3 *= array_size(array2,i);
        }
    }
    {
        Interpolator_prep(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_calc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    double *arg2 = (double *) 0 ;
    double *arg3 = (double *) 0 ;
    long arg4 ;
    long arg5 ;
    PyArrayObject *array2 = NULL ;
    double temp3[16] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOll:Interpolator_calc",&obj0,&obj1,&obj2,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
    }
    {
        int i;
        if (!PySequence_Check(obj2)) SWIG_fail;
        if (PySequence_Size(obj2)>16) SWIG_fail; /* arbitrary limit on dims */
        for (i=0; i<PySequence_Size(obj2); i++) {
            PyObject *o= PySequence_GetItem(obj2,i);
            if (PyNumber_Check(o)) temp3[i]= PyFloat_AsDouble(o);
            else SWIG_fail;
        }
        arg3= temp3;
    }
    {
        Interpolator_calc(arg1,arg2,arg3,arg4,arg5);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_dumpSelf(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    FILE *arg2 = (FILE *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:Interpolator_dumpSelf",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyFile_Check(obj1)) {
            arg2= PyFile_AsFile(obj1);
        } else {
            PyErr_SetString(PyExc_ValueError,"Input must be a file");
            return NULL;
        }
    }
    {
        Interpolator_dumpSelf(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_setInt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    int arg2 ;
    long arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oil:Interpolator_setInt",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Interpolator_setInt(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_setDouble(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    int arg2 ;
    double arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oid:Interpolator_setDouble",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Interpolator_setDouble(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_getInt(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    int arg2 ;
    long result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Interpolator_getInt",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (long)Interpolator_getInt(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_Interpolator_getDouble(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    int arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:Interpolator_getDouble",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (double)Interpolator_getDouble(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_Interpolator(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_Interpolator")) goto fail;
    {
        result = (Interpolator *)(Interpolator *) calloc(1, sizeof(Interpolator));
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * Interpolator_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_Interpolator, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_intrp_typeFromName(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    int result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:intrp_typeFromName",&arg1)) goto fail;
    {
        result = (int)intrp_typeFromName((char const *)arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_intrp_nameFromType(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    char *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:intrp_nameFromType",&arg1)) goto fail;
    {
        result = (char *)intrp_nameFromType((InterpolatorType )arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_intrp_warpClearCounts(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    
    if(!PyArg_ParseTuple(args,(char *)":intrp_warpClearCounts")) goto fail;
    {
        intrp_warpClearCounts();
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_intrp_warpGetCounts(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long *arg1 = (long *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:intrp_warpGetCounts",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_long,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        intrp_warpGetCounts(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_warpApply(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    Interpolator *arg1 = (Interpolator *) 0 ;
    Transform arg2 ;
    double *arg3 = (double *) 0 ;
    double *arg4 = (double *) 0 ;
    char *arg5 ;
    long arg6 ;
    long arg7 ;
    long arg8 ;
    long arg9 ;
    double arg10 ;
    double arg11 ;
    double arg12 ;
    double temp2[16] ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOsllllddd:warpApply",&obj0,&obj1,&obj2,&obj3,&arg5,&arg6,&arg7,&arg8,&arg9,&arg10,&arg11,&arg12)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Interpolator,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        int i;
        for (i = 0; i < 16; i++) {
            PyObject *o = PySequence_GetItem(obj1,i);
            if (PyNumber_Check(o)) {
                temp2[i] = PyFloat_AsDouble(o);
            } else {
                PyErr_SetString(PyExc_ValueError,"Sequence elements must be numbers");
                return NULL;
            }
        }
        bcopy(arg2,temp2,sizeof(Transform));
    }
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_double,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        intrp_warpApply(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createClosestInterpolator1D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long arg1 ;
    long arg2 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ll:createClosestInterpolator1D",&arg1,&arg2)) goto fail;
    {
        result = (Interpolator *)intrp_createClosestInterpolator1D(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createClosestInterpolator2D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long arg1 ;
    long arg2 ;
    long arg3 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"lll:createClosestInterpolator2D",&arg1,&arg2,&arg3)) goto fail;
    {
        result = (Interpolator *)intrp_createClosestInterpolator2D(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createClosestInterpolator3D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long arg1 ;
    long arg2 ;
    long arg3 ;
    long arg4 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"llll:createClosestInterpolator3D",&arg1,&arg2,&arg3,&arg4)) goto fail;
    {
        result = (Interpolator *)intrp_createClosestInterpolator3D(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createLinearInterpolator1D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long arg1 ;
    long arg2 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ll:createLinearInterpolator1D",&arg1,&arg2)) goto fail;
    {
        result = (Interpolator *)intrp_createLinearInterpolator1D(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createLinearInterpolator2D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long arg1 ;
    long arg2 ;
    long arg3 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"lll:createLinearInterpolator2D",&arg1,&arg2,&arg3)) goto fail;
    {
        result = (Interpolator *)intrp_createLinearInterpolator2D(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createLinearInterpolator3D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    long arg1 ;
    long arg2 ;
    long arg3 ;
    long arg4 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"llll:createLinearInterpolator3D",&arg1,&arg2,&arg3,&arg4)) goto fail;
    {
        result = (Interpolator *)intrp_createLinearInterpolator3D(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createSplineInterpolator1D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SplineType arg1 ;
    long arg2 ;
    long arg3 ;
    Interpolator *result;
    SplineType *argp1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oll:createSplineInterpolator1D",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &argp1, SWIGTYPE_p_SplineType,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg1 = *argp1; 
    {
        result = (Interpolator *)intrp_createSplineInterpolator1D(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createSplineInterpolator2D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SplineType arg1 ;
    long arg2 ;
    long arg3 ;
    long arg4 ;
    Interpolator *result;
    SplineType *argp1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Olll:createSplineInterpolator2D",&obj0,&arg2,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &argp1, SWIGTYPE_p_SplineType,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg1 = *argp1; 
    {
        result = (Interpolator *)intrp_createSplineInterpolator2D(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createSplineInterpolator3D(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    SplineType arg1 ;
    long arg2 ;
    long arg3 ;
    long arg4 ;
    long arg5 ;
    Interpolator *result;
    SplineType *argp1 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Ollll:createSplineInterpolator3D",&obj0,&arg2,&arg3,&arg4,&arg5)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &argp1, SWIGTYPE_p_SplineType,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
    arg1 = *argp1; 
    {
        result = (Interpolator *)intrp_createSplineInterpolator3D(arg1,arg2,arg3,arg4,arg5);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createInterpolator1DByType(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    long arg2 ;
    long arg3 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ill:createInterpolator1DByType",&arg1,&arg2,&arg3)) goto fail;
    {
        result = (Interpolator *)intrp_createInterpolator1DByType((InterpolatorType )arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createInterpolator2DByType(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    long arg2 ;
    long arg3 ;
    long arg4 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"illl:createInterpolator2DByType",&arg1,&arg2,&arg3,&arg4)) goto fail;
    {
        result = (Interpolator *)intrp_createInterpolator2DByType((InterpolatorType )arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createInterpolator3DByType(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    long arg2 ;
    long arg3 ;
    long arg4 ;
    long arg5 ;
    Interpolator *result;
    
    if(!PyArg_ParseTuple(args,(char *)"illll:createInterpolator3DByType",&arg1,&arg2,&arg3,&arg4,&arg5)) goto fail;
    {
        result = (Interpolator *)intrp_createInterpolator3DByType((InterpolatorType )arg1,arg2,arg3,arg4,arg5);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Interpolator, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_KalmanProcess(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KalmanProcess",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_KalmanProcess(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_dumpSelf(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    FILE *arg2 = (FILE *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_dumpSelf",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyFile_Check(obj1)) {
            arg2= PyFile_AsFile(obj1);
        } else {
            PyErr_SetString(PyExc_ValueError,"Input must be a file");
            return NULL;
        }
    }
    {
        KalmanProcess_dumpSelf(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_setDebug(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    int arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:KalmanProcess_setDebug",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        KalmanProcess_setDebug(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getDebug(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanProcess_getDebug",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)KalmanProcess_getDebug(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_setA(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    int is_new_object2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_setA",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_contiguous_allow_conversion(obj1, NPY_DOUBLE, &is_new_object2);
        npy_intp size[2] = {
            -1, -1 
        };
        if (!array2 || !require_dimensions(array2, 2) || !require_size(array2, size, 2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_setA(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return resultobj;
    fail:
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getA(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_getA",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,2) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_getA(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_setH(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    int is_new_object2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_setH",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_contiguous_allow_conversion(obj1, NPY_DOUBLE, &is_new_object2);
        npy_intp size[2] = {
            -1, -1 
        };
        if (!array2 || !require_dimensions(array2, 2) || !require_size(array2, size, 2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_setH(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return resultobj;
    fail:
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getH(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_getH",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,2) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_getH(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_setQ(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    int is_new_object2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_setQ",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_contiguous_allow_conversion(obj1, NPY_DOUBLE, &is_new_object2);
        npy_intp size[2] = {
            -1, -1 
        };
        if (!array2 || !require_dimensions(array2, 2) || !require_size(array2, size, 2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_setQ(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return resultobj;
    fail:
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getQ(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_getQ",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,2) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_getQ(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_setR(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    int is_new_object2 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_setR",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_contiguous_allow_conversion(obj1, NPY_DOUBLE, &is_new_object2);
        npy_intp size[2] = {
            -1, -1 
        };
        if (!array2 || !require_dimensions(array2, 2) || !require_size(array2, size, 2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_setR(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return resultobj;
    fail:
    {
        if (is_new_object2 && array2) Py_DECREF(array2);
    }
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getR(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanProcess_getR",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,2) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanProcess_getR(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getL(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanProcess_getL",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)KalmanProcess_getL(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_getM(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanProcess_getM",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)KalmanProcess_getM(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanProcess_apply(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    KalmanState *arg2 = (KalmanState *) 0 ;
    double *arg3 = (double *) 0 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    int arg7 ;
    double result;
    PyArrayObject *array3 = NULL ;
    int is_new_object3 = 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOiii:KalmanProcess_apply",&obj0,&obj1,&obj2,&arg5,&arg6,&arg7)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_KalmanState,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array3 = obj_to_array_contiguous_allow_conversion(obj2, NPY_DOUBLE, &is_new_object3);
        npy_intp size[1] = {
            -1 
        };
        if (!array3 || !require_dimensions(array3, 1) || !require_size(array3, size, 1)) SWIG_fail;
        arg3 = (double*) array_data(array3);
        arg4 = (int) array_size(array3,0);
    }
    {
        result = (double)KalmanProcess_apply(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyFloat_FromDouble(result);
    {
        if (is_new_object3 && array3) Py_DECREF(array3);
    }
    return resultobj;
    fail:
    {
        if (is_new_object3 && array3) Py_DECREF(array3);
    }
    return NULL;
}


static PyObject *_wrap_new_KalmanProcess(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_KalmanProcess")) goto fail;
    {
        result = (KalmanProcess *)(KalmanProcess *) calloc(1, sizeof(KalmanProcess));
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanProcess, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KalmanProcess_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_KalmanProcess, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_KalmanState(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanState *arg1 = (KalmanState *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KalmanState",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanState,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_KalmanState(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanState_dumpSelf(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanState *arg1 = (KalmanState *) 0 ;
    FILE *arg2 = (FILE *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanState_dumpSelf",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanState,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyFile_Check(obj1)) {
            arg2= PyFile_AsFile(obj1);
        } else {
            PyErr_SetString(PyExc_ValueError,"Input must be a file");
            return NULL;
        }
    }
    {
        KalmanState_dumpSelf(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanState_setX(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanState *arg1 = (KalmanState *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanState_setX",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanState,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,1) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = 1;
        {
            int i;
            for (i=0; i < array_numdims(array2); ++i) arg3 *= array_size(array2,i);
        }
    }
    {
        KalmanState_setX(arg1,arg2,arg3);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanState_setP(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanState *arg1 = (KalmanState *) 0 ;
    double *arg2 = (double *) 0 ;
    int arg3 ;
    int arg4 ;
    PyArrayObject *array2 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanState_setP",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanState,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array2 = obj_to_array_no_conversion(obj1, NPY_DOUBLE);
        if (!array2 || !require_dimensions(array2,2) || !require_contiguous(array2)
        || !require_native(array2)) SWIG_fail;
        arg2 = (double*) array_data(array2);
        arg3 = (int) array_size(array2,0);
        arg4 = (int) array_size(array2,1);
    }
    {
        KalmanState_setP(arg1,arg2,arg3,arg4);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanState_getM(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanState *arg1 = (KalmanState *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanState_getM",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanState,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)KalmanState_getM(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_KalmanState(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanState *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_KalmanState")) goto fail;
    {
        result = (KalmanState *)(KalmanState *) calloc(1, sizeof(KalmanState));
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanState, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KalmanState_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_KalmanState, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_delete_KalmanFilter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *arg1 = (KalmanFilter *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_KalmanFilter",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanFilter,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        delete_KalmanFilter(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanFilter_dumpSelf(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *arg1 = (KalmanFilter *) 0 ;
    FILE *arg2 = (FILE *) 0 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:KalmanFilter_dumpSelf",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanFilter,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        if (PyFile_Check(obj1)) {
            arg2= PyFile_AsFile(obj1);
        } else {
            PyErr_SetString(PyExc_ValueError,"Input must be a file");
            return NULL;
        }
    }
    {
        KalmanFilter_dumpSelf(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanFilter_getL(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *arg1 = (KalmanFilter *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanFilter_getL",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanFilter,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)KalmanFilter_getL(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanFilter_getM(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *arg1 = (KalmanFilter *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanFilter_getM",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanFilter,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (int)KalmanFilter_getM(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanFilter_getState(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *arg1 = (KalmanFilter *) 0 ;
    KalmanState *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:KalmanFilter_getState",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanFilter,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (KalmanState *)KalmanFilter_getState(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanState, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_KalmanFilter_run(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *arg1 = (KalmanFilter *) 0 ;
    long arg2 ;
    double *arg3 = (double *) 0 ;
    int arg4 ;
    int arg5 ;
    double *arg6 = (double *) 0 ;
    int arg7 ;
    int arg8 ;
    double *arg9 = (double *) 0 ;
    int arg10 ;
    int arg11 ;
    int arg12 ;
    int arg13 ;
    double result;
    PyArrayObject *array3 = NULL ;
    int is_new_object3 = 0 ;
    PyArrayObject *array4 = NULL ;
    PyArrayObject *array5 = NULL ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OlOOOi:KalmanFilter_run",&obj0,&arg2,&obj2,&obj3,&obj4,&arg13)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanFilter,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        array3 = obj_to_array_contiguous_allow_conversion(obj2, NPY_DOUBLE, &is_new_object3);
        npy_intp size[2] = {
            -1, -1 
        };
        if (!array3 || !require_dimensions(array3, 2) || !require_size(array3, size, 2)) SWIG_fail;
        arg3 = (double*) array_data(array3);
        arg4 = (int) array_size(array3,0);
        arg5 = (int) array_size(array3,1);
    }
    {
        array4 = obj_to_array_no_conversion(obj3, NPY_DOUBLE);
        if (!array4 || !require_dimensions(array4,2) || !require_contiguous(array4)
        || !require_native(array4)) SWIG_fail;
        arg6 = (double*) array_data(array4);
        arg7 = (int) array_size(array4,0);
        arg8 = (int) array_size(array4,1);
    }
    {
        array5 = obj_to_array_no_conversion(obj4, NPY_DOUBLE);
        if (!array5 || !require_dimensions(array5,3) || !require_contiguous(array5)
        || !require_native(array5)) SWIG_fail;
        arg9 = (double*) array_data(array5);
        arg10 = (int) array_size(array5,0);
        arg11 = (int) array_size(array5,1);
        arg12 = (int) array_size(array5,2);
    }
    {
        result = (double)KalmanFilter_run(arg1,arg2,(double const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = PyFloat_FromDouble(result);
    {
        if (is_new_object3 && array3) Py_DECREF(array3);
    }
    return resultobj;
    fail:
    {
        if (is_new_object3 && array3) Py_DECREF(array3);
    }
    return NULL;
}


static PyObject *_wrap_new_KalmanFilter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanFilter *result;
    
    if(!PyArg_ParseTuple(args,(char *)":new_KalmanFilter")) goto fail;
    {
        result = (KalmanFilter *)(KalmanFilter *) calloc(1, sizeof(KalmanFilter));
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanFilter, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * KalmanFilter_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_KalmanFilter, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_createKalmanProcess(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    int arg2 ;
    KalmanProcess *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ii:createKalmanProcess",&arg1,&arg2)) goto fail;
    {
        result = (KalmanProcess *)klmn_createRowMajorKalmanProcess(arg1,arg2);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanProcess, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createKalmanState(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg1 ;
    KalmanState *result;
    
    if(!PyArg_ParseTuple(args,(char *)"i:createKalmanState",&arg1)) goto fail;
    {
        result = (KalmanState *)klmn_createRowMajorKalmanState(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanState, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_createKalmanFilter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    KalmanProcess *arg1 = (KalmanProcess *) 0 ;
    KalmanFilter *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:createKalmanFilter",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_KalmanProcess,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        result = (KalmanFilter *)klmn_createKalmanFilter(arg1);
        
        if (PyErr_Occurred()) SWIG_fail;
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_KalmanFilter, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"new_Regressor", _wrap_new_Regressor, METH_VARARGS },
	 { (char *)"delete_Regressor", _wrap_delete_Regressor, METH_VARARGS },
	 { (char *)"Regressor_get", _wrap_Regressor_get, METH_VARARGS },
	 { (char *)"Regressor_is_settable", _wrap_Regressor_is_settable, METH_VARARGS },
	 { (char *)"Regressor_set", _wrap_Regressor_set, METH_VARARGS },
	 { (char *)"Regressor_n_params", _wrap_Regressor_n_params, METH_VARARGS },
	 { (char *)"Regressor_fit", _wrap_Regressor_fit, METH_VARARGS },
	 { (char *)"Regressor_context_valid", _wrap_Regressor_context_valid, METH_VARARGS },
	 { (char *)"Regressor_swigregister", Regressor_swigregister, METH_VARARGS },
	 { (char *)"create_base_regressor", _wrap_create_base_regressor, METH_VARARGS },
	 { (char *)"create_llsq_regressor", _wrap_create_llsq_regressor, METH_VARARGS },
	 { (char *)"create_logistic_regressor", _wrap_create_logistic_regressor, METH_VARARGS },
	 { (char *)"create_poisson_regressor", _wrap_create_poisson_regressor, METH_VARARGS },
	 { (char *)"delete_ScalarFunction", _wrap_delete_ScalarFunction, METH_VARARGS },
	 { (char *)"ScalarFunction_value", _wrap_ScalarFunction_value, METH_VARARGS },
	 { (char *)"ScalarFunction_reset", _wrap_ScalarFunction_reset, METH_VARARGS },
	 { (char *)"new_ScalarFunction", _wrap_new_ScalarFunction, METH_VARARGS },
	 { (char *)"ScalarFunction_swigregister", ScalarFunction_swigregister, METH_VARARGS },
	 { (char *)"buildSimpleScalarFunction", _wrap_buildSimpleScalarFunction, METH_VARARGS },
	 { (char *)"delete_Optimizer", _wrap_delete_Optimizer, METH_VARARGS },
	 { (char *)"Optimizer___str__", _wrap_Optimizer___str__, METH_VARARGS },
	 { (char *)"Optimizer___repr__", _wrap_Optimizer___repr__, METH_VARARGS },
	 { (char *)"Optimizer_getDebugLevel", _wrap_Optimizer_getDebugLevel, METH_VARARGS },
	 { (char *)"Optimizer_setDebugLevel", _wrap_Optimizer_setDebugLevel, METH_VARARGS },
	 { (char *)"Optimizer_go", _wrap_Optimizer_go, METH_VARARGS },
	 { (char *)"new_Optimizer", _wrap_new_Optimizer, METH_VARARGS },
	 { (char *)"Optimizer_swigregister", Optimizer_swigregister, METH_VARARGS },
	 { (char *)"optimizerFromStringRep", _wrap_optimizerFromStringRep, METH_VARARGS },
	 { (char *)"createBaseOptimizer", _wrap_createBaseOptimizer, METH_VARARGS },
	 { (char *)"createNoneOptimizer", _wrap_createNoneOptimizer, METH_VARARGS },
	 { (char *)"createPraxisOptimizer", _wrap_createPraxisOptimizer, METH_VARARGS },
	 { (char *)"createNelminOptimizer", _wrap_createNelminOptimizer, METH_VARARGS },
	 { (char *)"createNelminTOptimizer", _wrap_createNelminTOptimizer, METH_VARARGS },
	 { (char *)"delete_Interpolator", _wrap_delete_Interpolator, METH_VARARGS },
	 { (char *)"Interpolator_getTypeName", _wrap_Interpolator_getTypeName, METH_VARARGS },
	 { (char *)"Interpolator_prep", _wrap_Interpolator_prep, METH_VARARGS },
	 { (char *)"Interpolator_calc", _wrap_Interpolator_calc, METH_VARARGS },
	 { (char *)"Interpolator_dumpSelf", _wrap_Interpolator_dumpSelf, METH_VARARGS },
	 { (char *)"Interpolator_setInt", _wrap_Interpolator_setInt, METH_VARARGS },
	 { (char *)"Interpolator_setDouble", _wrap_Interpolator_setDouble, METH_VARARGS },
	 { (char *)"Interpolator_getInt", _wrap_Interpolator_getInt, METH_VARARGS },
	 { (char *)"Interpolator_getDouble", _wrap_Interpolator_getDouble, METH_VARARGS },
	 { (char *)"new_Interpolator", _wrap_new_Interpolator, METH_VARARGS },
	 { (char *)"Interpolator_swigregister", Interpolator_swigregister, METH_VARARGS },
	 { (char *)"intrp_typeFromName", _wrap_intrp_typeFromName, METH_VARARGS },
	 { (char *)"intrp_nameFromType", _wrap_intrp_nameFromType, METH_VARARGS },
	 { (char *)"intrp_warpClearCounts", _wrap_intrp_warpClearCounts, METH_VARARGS },
	 { (char *)"intrp_warpGetCounts", _wrap_intrp_warpGetCounts, METH_VARARGS },
	 { (char *)"warpApply", _wrap_warpApply, METH_VARARGS },
	 { (char *)"createClosestInterpolator1D", _wrap_createClosestInterpolator1D, METH_VARARGS },
	 { (char *)"createClosestInterpolator2D", _wrap_createClosestInterpolator2D, METH_VARARGS },
	 { (char *)"createClosestInterpolator3D", _wrap_createClosestInterpolator3D, METH_VARARGS },
	 { (char *)"createLinearInterpolator1D", _wrap_createLinearInterpolator1D, METH_VARARGS },
	 { (char *)"createLinearInterpolator2D", _wrap_createLinearInterpolator2D, METH_VARARGS },
	 { (char *)"createLinearInterpolator3D", _wrap_createLinearInterpolator3D, METH_VARARGS },
	 { (char *)"createSplineInterpolator1D", _wrap_createSplineInterpolator1D, METH_VARARGS },
	 { (char *)"createSplineInterpolator2D", _wrap_createSplineInterpolator2D, METH_VARARGS },
	 { (char *)"createSplineInterpolator3D", _wrap_createSplineInterpolator3D, METH_VARARGS },
	 { (char *)"createInterpolator1DByType", _wrap_createInterpolator1DByType, METH_VARARGS },
	 { (char *)"createInterpolator2DByType", _wrap_createInterpolator2DByType, METH_VARARGS },
	 { (char *)"createInterpolator3DByType", _wrap_createInterpolator3DByType, METH_VARARGS },
	 { (char *)"delete_KalmanProcess", _wrap_delete_KalmanProcess, METH_VARARGS },
	 { (char *)"KalmanProcess_dumpSelf", _wrap_KalmanProcess_dumpSelf, METH_VARARGS },
	 { (char *)"KalmanProcess_setDebug", _wrap_KalmanProcess_setDebug, METH_VARARGS },
	 { (char *)"KalmanProcess_getDebug", _wrap_KalmanProcess_getDebug, METH_VARARGS },
	 { (char *)"KalmanProcess_setA", _wrap_KalmanProcess_setA, METH_VARARGS },
	 { (char *)"KalmanProcess_getA", _wrap_KalmanProcess_getA, METH_VARARGS },
	 { (char *)"KalmanProcess_setH", _wrap_KalmanProcess_setH, METH_VARARGS },
	 { (char *)"KalmanProcess_getH", _wrap_KalmanProcess_getH, METH_VARARGS },
	 { (char *)"KalmanProcess_setQ", _wrap_KalmanProcess_setQ, METH_VARARGS },
	 { (char *)"KalmanProcess_getQ", _wrap_KalmanProcess_getQ, METH_VARARGS },
	 { (char *)"KalmanProcess_setR", _wrap_KalmanProcess_setR, METH_VARARGS },
	 { (char *)"KalmanProcess_getR", _wrap_KalmanProcess_getR, METH_VARARGS },
	 { (char *)"KalmanProcess_getL", _wrap_KalmanProcess_getL, METH_VARARGS },
	 { (char *)"KalmanProcess_getM", _wrap_KalmanProcess_getM, METH_VARARGS },
	 { (char *)"KalmanProcess_apply", _wrap_KalmanProcess_apply, METH_VARARGS },
	 { (char *)"new_KalmanProcess", _wrap_new_KalmanProcess, METH_VARARGS },
	 { (char *)"KalmanProcess_swigregister", KalmanProcess_swigregister, METH_VARARGS },
	 { (char *)"delete_KalmanState", _wrap_delete_KalmanState, METH_VARARGS },
	 { (char *)"KalmanState_dumpSelf", _wrap_KalmanState_dumpSelf, METH_VARARGS },
	 { (char *)"KalmanState_setX", _wrap_KalmanState_setX, METH_VARARGS },
	 { (char *)"KalmanState_setP", _wrap_KalmanState_setP, METH_VARARGS },
	 { (char *)"KalmanState_getM", _wrap_KalmanState_getM, METH_VARARGS },
	 { (char *)"new_KalmanState", _wrap_new_KalmanState, METH_VARARGS },
	 { (char *)"KalmanState_swigregister", KalmanState_swigregister, METH_VARARGS },
	 { (char *)"delete_KalmanFilter", _wrap_delete_KalmanFilter, METH_VARARGS },
	 { (char *)"KalmanFilter_dumpSelf", _wrap_KalmanFilter_dumpSelf, METH_VARARGS },
	 { (char *)"KalmanFilter_getL", _wrap_KalmanFilter_getL, METH_VARARGS },
	 { (char *)"KalmanFilter_getM", _wrap_KalmanFilter_getM, METH_VARARGS },
	 { (char *)"KalmanFilter_getState", _wrap_KalmanFilter_getState, METH_VARARGS },
	 { (char *)"KalmanFilter_run", _wrap_KalmanFilter_run, METH_VARARGS },
	 { (char *)"new_KalmanFilter", _wrap_new_KalmanFilter, METH_VARARGS },
	 { (char *)"KalmanFilter_swigregister", KalmanFilter_swigregister, METH_VARARGS },
	 { (char *)"createKalmanProcess", _wrap_createKalmanProcess, METH_VARARGS },
	 { (char *)"createKalmanState", _wrap_createKalmanState, METH_VARARGS },
	 { (char *)"createKalmanFilter", _wrap_createKalmanFilter, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Transform[] = {{"_p_Transform", 0, "Transform *", 0},{"_p_Transform"},{0}};
static swig_type_info _swigt__p_double[] = {{"_p_double", 0, "double *", 0},{"_p_double"},{0}};
static swig_type_info _swigt__p_SFUNVALUEFUNC[] = {{"_p_SFUNVALUEFUNC", 0, "SFUNVALUEFUNC *", 0},{"_p_SFUNVALUEFUNC"},{0}};
static swig_type_info _swigt__p_SFUNRESETFUNC[] = {{"_p_SFUNRESETFUNC", 0, "SFUNRESETFUNC *", 0},{"_p_SFUNRESETFUNC"},{0}};
static swig_type_info _swigt__p_KalmanState[] = {{"_p_KalmanState", 0, "KalmanState *", 0},{"_p_KalmanState"},{0}};
static swig_type_info _swigt__p_ScalarFunction[] = {{"_p_ScalarFunction", 0, "ScalarFunction *", 0},{"_p_ScalarFunction"},{0}};
static swig_type_info _swigt__p_SplineType[] = {{"_p_SplineType", 0, "SplineType *", 0},{"_p_SplineType"},{0}};
static swig_type_info _swigt__p_Interpolator[] = {{"_p_Interpolator", 0, "Interpolator *", 0},{"_p_Interpolator"},{0}};
static swig_type_info _swigt__p_Optimizer[] = {{"_p_Optimizer", 0, "Optimizer *", 0},{"_p_Optimizer"},{0}};
static swig_type_info _swigt__p_FILE[] = {{"_p_FILE", 0, "FILE *", 0},{"_p_FILE"},{0}};
static swig_type_info _swigt__p_long[] = {{"_p_long", 0, "long *", 0},{"_p_long"},{0}};
static swig_type_info _swigt__p_KalmanProcess[] = {{"_p_KalmanProcess", 0, "KalmanProcess *", 0},{"_p_KalmanProcess"},{0}};
static swig_type_info _swigt__p_Regressor[] = {{"_p_Regressor", 0, "Regressor *", 0},{"_p_Regressor"},{0}};
static swig_type_info _swigt__p_KalmanFilter[] = {{"_p_KalmanFilter", 0, "KalmanFilter *", 0},{"_p_KalmanFilter"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Transform, 
_swigt__p_double, 
_swigt__p_SFUNVALUEFUNC, 
_swigt__p_SFUNRESETFUNC, 
_swigt__p_KalmanState, 
_swigt__p_ScalarFunction, 
_swigt__p_SplineType, 
_swigt__p_Interpolator, 
_swigt__p_Optimizer, 
_swigt__p_FILE, 
_swigt__p_long, 
_swigt__p_KalmanProcess, 
_swigt__p_Regressor, 
_swigt__p_KalmanFilter, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{ SWIG_PY_INT,     (char *)"GLM_COMPLEX", (long) GLM_COMPLEX, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_RESIDUALS", (long) GLM_RESIDUALS, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_VARIANCES", (long) GLM_VARIANCES, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_COVARIANCES", (long) GLM_COVARIANCES, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_SSQR", (long) GLM_SSQR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_ORTHO", (long) GLM_ORTHO, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_DEBUG", (long) GLM_DEBUG, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_DEVIANCE", (long) GLM_DEVIANCE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_TYPE", (long) GLM_TYPE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_TYPE_BASE", (long) GLM_TYPE_BASE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_TYPE_LLSQ", (long) GLM_TYPE_LLSQ, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_TYPE_LOGISTIC", (long) GLM_TYPE_LOGISTIC, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"GLM_TYPE_POISSON", (long) GLM_TYPE_POISSON, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_CLOSEST", (long) INTRP_CLOSEST, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_LINEAR", (long) INTRP_LINEAR, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_CATMULLROM", (long) INTRP_CATMULLROM, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_BEZIER", (long) INTRP_BEZIER, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_BSPLINE", (long) INTRP_BSPLINE, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_UNKNOWN", (long) INTRP_UNKNOWN, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_OPT_DEBUG", (long) INTRP_OPT_DEBUG, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_OPT_FASTBLK", (long) INTRP_OPT_FASTBLK, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_OPT_EXTENT", (long) INTRP_OPT_EXTENT, 0, 0, 0},
{ SWIG_PY_INT,     (char *)"INTRP_OPT_TENSION", (long) INTRP_OPT_TENSION, 0, 0, 0},
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
    
    import_array(); 
    
}

